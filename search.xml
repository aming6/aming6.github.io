<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JAVA面试题</title>
      <link href="/2022/10/18/JAVA%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/10/18/JAVA%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象编程三大特性: 封装 继承 多态</p><ul><li><p>封装</p><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。</p></li><li><p>继承</p><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p></li><li><p>多态</p><p>所谓多态，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p></li></ul><h2 id="JDK、JRE的区别"><a href="#JDK、JRE的区别" class="headerlink" title="JDK、JRE的区别"></a>JDK、JRE的区别</h2><ul><li><p>JDK：提供了 Java 的开发环境和运行环境。（JRE+JAVA工具包）</p></li><li><p>JRE：为 Java 的运行提供了所需环境。（JVM+JAVASE标准类库）</p></li></ul><p>简单来说：JDK中包含JRE，JDK中有一个名为jre的目录，里面包含两个文件夹bin和lib，bin就是JVM，lib就是JVM工作所需要的类库。</p><h2 id="简单的说说JVM"><a href="#简单的说说JVM" class="headerlink" title="简单的说说JVM"></a>简单的说说JVM</h2><p>JVM是Java的虚拟机，是Java语言跨平台的关键。JVM由三部分组成：<strong>类加载子系统</strong>，<strong>执行引擎</strong>，<strong>运行时数据区</strong>。</p><ol><li><p>类加载子系统：类加载子系统负责加载class信息，加载的类信息存放于方法区中。</p></li><li><p>执行引擎：负责执行那些包含在被载入类的方法中的指令。</p></li><li><p>当程序运行时，JVM需要内存来存储许多内容，例如：字节码、对象、参数等，JVM会把这些东西都存储到运行时数据区中，以便于管理。</p><p>而运行时数据区又可以分为<strong>方法区</strong>、<strong>堆</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>、<strong>程序计数器</strong>。</p></li></ol><h2 id="x3D-x3D-和-equals-的区别是什么？"><a href="#x3D-x3D-和-equals-的区别是什么？" class="headerlink" title="&#x3D;&#x3D; 和 equals 的区别是什么？"></a>&#x3D;&#x3D; 和 <a href="https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020">equals</a> 的区别是什么？</h2><ul><li><p>&#x3D;&#x3D; 比较基本类型，比较的是值，&#x3D;&#x3D;比较引用类型，比较的是内存地址</p></li><li><p>equlas是Object类的方法，本质上与&#x3D;&#x3D;一样，但是有些类重写了equals方法，比如String的equals被重写后，比较的是字符值。另外重写了equlas后，也必须重写hashcode()方法</p></li></ul><h2 id="final-在-java-中有什么作用？"><a href="#final-在-java-中有什么作用？" class="headerlink" title="final 在 java 中有什么作用？"></a>final 在 java 中有什么作用？</h2><ol><li><p>用来修饰类</p><p>当用final修改类时，该类无法被继承。比如常用的String类就是最终类。</p></li><li><p>用来修饰一个方法</p><p>当使用final修饰方法时，这个方法将无法被子类重写。但是，该方法仍然可以被继承。</p></li><li><p>用来修饰变量</p><p>final修饰变量，如果变量为基本数据类型，则该值不能再改变，如果变量为引用数据类型，则引用地址不能改变，但值可以改变。</p></li></ol><h2 id="String-str-x3D-”i”与-String-str-x3D-new-String-“i”-一样吗？"><a href="#String-str-x3D-”i”与-String-str-x3D-new-String-“i”-一样吗？" class="headerlink" title="String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？"></a>String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？</h2><p>Java中创建字符串有两种方式</p><ul><li><p>第一种是通过String类直接定义一串字符，JVM会将该字符串放在常量池中，如果再用该方法定义一个相同的字符串则JVM会去常量池中寻找是否已有该字符串，没有则会重建一个；如果已有则不会新建，两个字符串的地址相等（用&#x3D;符号会判定为true）；</p></li><li><p>但用new的方式定义字符串相当于在String类中新建了一个对象，用这种方式创建字符串时虽然也是放在常量池中但每次都会新建一个对象放在堆内存中，两个相同字符串的地址不同（用&#x3D;符号会判断为false）。</p></li></ul><h2 id="说说对反射的了解"><a href="#说说对反射的了解" class="headerlink" title="说说对反射的了解"></a>说说对反射的了解</h2><p>反射就是在程序运行期间动态的获取对象的属性和方法的功能叫做反射。</p><p>它能够在程序运行期间，对于任意一个类，都能知道它所有的方法和属性；</p><p>获取Class对象的三种方式：getClass()；xx.class；Class.forName(“xxx”)；</p><p>反射的优缺点： </p><p>优点：运行期间能够动态的获取类，提高代码的灵活性。</p><p> 缺点：性能比直接的Java代码要慢很多。 应用场景：spring的xml配置模式，以及动态代理模式都用到了反射。</p><h2 id="StringBuilder和StringBuffer的区别"><a href="#StringBuilder和StringBuffer的区别" class="headerlink" title="StringBuilder和StringBuffer的区别"></a>StringBuilder和StringBuffer的区别</h2><ol><li>他们都是可变长度的字符串</li><li>StringBuffer  线程安全   效率低</li><li>StringBuilder  线程不安全  效率高</li></ol><h2 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h2><p>抽象类不能被实例化，由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用</p><p>抽象类可以有抽象方法，只需申明，无须实现，有抽象方法的类一定是抽象类</p><p>抽象类的子类必须实现抽象类中的所有抽象方法，否则子类仍然是抽象类</p><p>抽象方法不能被static、final修饰</p><h2 id="接口和抽象类有什么区别？"><a href="#接口和抽象类有什么区别？" class="headerlink" title="接口和抽象类有什么区别？"></a>接口和抽象类有什么区别？</h2><p>接口使用interface修饰；抽象类使用abstract修饰</p><p>接口不能实例化；抽象类也不能被实例化</p><p>类可以实现多个接口；抽象类只能单继承</p><p>java8之后；接口中可以定义静态方法，静态方法必须有方法体，普通方法没有方法体，需要被实现；</p><p>抽象类中可以包含抽象方法和非抽象方法，非抽象方法需要有方法体</p><p>如果一个类继承了抽象类，如果没有实现所有的抽象方法，子类仍然是抽象类。</p><h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><p>相似点：</p><ol><li>接口和抽象都不能被实例化</li><li>实现接口或者继承抽象类的普通子类都必须实现这些抽象方法</li></ol><p>不同点：</p><ol><li>接口使用interface修饰；抽象类使用abstract修饰</li><li>类可以实现多个接口；抽象类只能单继承</li><li>抽象类可以包含普通方法和代码块；接口里只能包含抽象方法，静态方法和默认方法</li><li>抽象类可以有构造方法，而接口没有</li><li>抽象类中的成员变量可以是各种类型的，而接口的成员变量只能是public、static、final类型的，并且必须赋值</li></ol><h2 id="throw-和-throws-的区别？"><a href="#throw-和-throws-的区别？" class="headerlink" title="throw 和 throws 的区别？"></a>throw 和 throws 的区别？</h2><ol><li><p>throw</p><p>作用在方法内，表示抛出具体异常，由方法体内的语句处理；<br>一定抛出了异常；</p></li><li><p>throws</p><p>作用在方法的声明上，表示抛出异常，由调用者来进行异常处理；<br>可能出现异常，不一定会发生异常；</p></li></ol><h2 id="final、finally、finalize-有什么区别？"><a href="#final、finally、finalize-有什么区别？" class="headerlink" title="final、finally、finalize 有什么区别？"></a>final、finally、finalize 有什么区别？</h2><ul><li><p>final可以修饰类，变量，方法，修饰的类不能被继承，修饰的变量不能重新赋值，修饰的方法不能被重写</p></li><li><p>finally用于抛异常，finally代码块内语句无论是否发生异常，都会在执行finally，常用于一些流的关闭。</p></li><li><p>finalize方法用于垃圾回收。</p></li></ul><h2 id="java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="java 中操作字符串都有哪些类？它们之间有什么区别？"></a>java 中操作字符串都有哪些类？它们之间有什么区别？</h2><ul><li><p>String</p><p>String是不可变对象，每次对String类型的改变时都会生成一个新的对象。</p></li><li><p>StringBuilder</p><p>线程不安全，效率高，多用于单线程。</p></li><li><p>StringBuffer</p><p>线程安全，由于加锁的原因，效率不如StringBuilder，多用于多线程。</p></li></ul><h2 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h2><ul><li><p>Collection是最基本的集合接口，Collection派生了两个子接口list和set，分别定义了两种不同的存储方式。</p></li><li><p>Collections是一个包装类，它包含各种有关集合操作的静态方法（对集合的搜索、排序、线程安全化等）。此类不能实例化，就像一个工具类，服务于Collection框架。</p></li></ul><h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><ul><li><p>重载发生在同一个类中，方法名相同，参数列表、返回值类型或权限修饰符不同</p></li><li><p>重写发生在子类中，方法名、参数列表、返回值类型都相同</p></li><li><p>权限修饰符要大于父类方法，声明异常范围要小于父类方法，但是final和private修饰的方法不可重写</p></li></ul><h2 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h2><p>HashMap在Jdk1.8以后是基于数组+链表+红黑树来实现的，特点是，key不能重复，可以为null，线程不安全</p><h2 id="想要线程安全的HashMap怎么办？"><a href="#想要线程安全的HashMap怎么办？" class="headerlink" title="想要线程安全的HashMap怎么办？"></a>想要线程安全的HashMap怎么办？</h2><ol><li><p>使用ConcurrentHashMap</p></li><li><p>使用HashTable</p></li><li><p>Collections.synchronizedHashMap()方法</p></li></ol><h2 id="HashTable与HashMap的区别"><a href="#HashTable与HashMap的区别" class="headerlink" title="HashTable与HashMap的区别"></a>HashTable与HashMap的区别</h2><ol><li><p>HashTable的每个方法都用synchronized修饰，因此是线程安全的，但同时读写效率很低</p></li><li><p>HashTable的Key不允许为null，HashMap可以</p></li><li><p>HashTable只对key进行一次hash，HashMap进行了两次Hash</p></li><li><p>HashTable底层使用的数组加链表，HashMap底层使用的是数组加链表加红黑树</p></li></ol><h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2><p>ArrayList底层使用的是动态数组，默认容量为10，当元素数量到达容量时，会生成一个新的数组，大小为前一次的1.5倍，然后将原来的数组copy过来；因为数组在内存中是连续的地址，所以ArrayList查找数据更快，由于扩容机制添加数据效率更低</p><p>LinkedList底层使用的是链表，在内存中是离散的，没有扩容机制；LinkedList在查找数据是需要从头遍历，所以查的慢，但添加数据效率更高</p><h2 id="如何保证ArrayList的线程安全？"><a href="#如何保证ArrayList的线程安全？" class="headerlink" title="如何保证ArrayList的线程安全？"></a>如何保证ArrayList的线程安全？</h2><ol><li><p>使用collentions.synchronizedList（）方法为ArrayList加锁</p></li><li><p>使用Vector，Vector底层与Arraylist相同，但是每个方法都由synchronized修饰，速度很慢</p></li></ol><h2 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h2><ol><li>String</li></ol><p>String是不可变对象，每次对String类型的改变时都会生成一个新的对象。</p><ol start="2"><li>StringBuilder</li></ol><p>线程不安全，效率高，多用于单线程。</p><ol start="3"><li>StringBuffer</li></ol><p>线程安全，由于加锁的原因，效率不如StringBuilder，多用于多线程。</p><h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><p>cookies：存放在客户浏览器中，每次http请求都会携带，通常用来告知服务端两个请求是否来自同一浏览器，单个cookie存储的数据不能超过4k,一般存储数据不能超过20个，</p><p>session：存放在服务器中，相比cookie他的安全性更高，但失效时间较短</p><p>当用户第一次访问服务器时，服务器会返回一个sessionId给浏览器并存入cookie，然后浏览器再次访问服务器会根据cookie中的sessionId去查找对应的session信息，用这套机制来使服务器和客户端进行对话</p><h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><p>概念：进程是系统运行程序的基本单位，线程是CPU调度的最小单位。 </p><p>1.地址空间。进程有独立的地址空间,一个进程可以有多个线程；线程没有自己独立的地址空间，而是共享进程的堆和方法区，但是有自己的程序计数器、虚拟机栈和本地方法栈 。</p><p>2.开销。进程和线程切换的都要进行上下文切换，进程切换上下文的开销远大于线程的上下文切换时间，耗费资源也较大，效率差一些 。</p><p>3.并发。进程粒度要粗，并发性较低，线程的并发性较高。</p><p>4.使用。进程可以独立执行。但是线程不能独立执行，必须依存在一个进程中，由进程提供多个线程的执行控制。</p><h2 id="请你说说多线程"><a href="#请你说说多线程" class="headerlink" title="请你说说多线程"></a>请你说说多线程</h2><p>线程是CPU调度的最小单元，一个进程可以存在多个线程，每个线程有独立的运行栈和程序计数器。</p><p>实现多线程有三种方式：继承Tread类，实现Runable接口；实现Callable接口。</p><p>多线程可以提高程序的相应速度，但是多线同时也会造成内存占用过多，共享资源影响和控制复杂等问题</p><h2 id="说说怎么保证线程安全"><a href="#说说怎么保证线程安全" class="headerlink" title="说说怎么保证线程安全"></a>说说怎么保证线程安全</h2><p>多个线程同时操作共享资源时，就会出现线程安全问题。这时就需要我们使用同步方案保证线程安全，常见的保证线程安全的方式有：<strong>原子类</strong>(底层使用CAS算法实现)、<strong>volatile关键字</strong>(1.可见性、2.防止指令重排、3.不保证原子性)、<strong>Lock类</strong>、<strong>锁</strong>(JUC包下的lock锁)、<strong>synchronized关键字</strong>等保证线程安全，使用ThreadLocal可以为每一个线程单独保存一份数据，避免了多线程访问共享变量。</p><h2 id="请你说说死锁定义及发生的条件"><a href="#请你说说死锁定义及发生的条件" class="headerlink" title="请你说说死锁定义及发生的条件"></a>请你说说死锁定义及发生的条件</h2><p>两个或者两个以上进程互相竞争资源而造成持续等待的情况。若无外力则会一直等待下去，这就叫死锁。</p><p> 死锁产生的条件： </p><p><strong>互斥</strong>：一个资源在同一个时刻只能由一个线程执行 </p><p><strong>请求与保持</strong>：一个线程在请求被占用资源时，对已经获得的资源保持不放。</p><p><strong>循环等待</strong>：若干个进程形成环形链，每个都占用对方申请的下一个资源。 </p><p><strong>不可剥夺条件</strong>：线程对所获得的资源在未使用完时不能被其他线程剥夺，只能自己释放。</p><p>避免死锁的方法就是破坏死锁产生的条件。</p><h2 id="Synchrpnized和lock的区别"><a href="#Synchrpnized和lock的区别" class="headerlink" title="Synchrpnized和lock的区别"></a>Synchrpnized和lock的区别</h2><ol><li><p>synchronized是关键字，lock是一个类</p></li><li><p>synchronized在发生异常时会自动释放锁，lock需要手动释放锁</p></li><li><p>synchronized是可重入锁、非公平锁、不可中断锁，lock的ReentrantLock是可重入锁，可中断锁，可以是公平锁也可以是非公平锁</p></li><li><p>synchronized是JVM层次通过监视器实现的，Lock是通过AQS实现的</p></li></ol><h2 id="sleep-和wait-的区别"><a href="#sleep-和wait-的区别" class="headerlink" title="sleep()和wait()的区别"></a>sleep()和wait()的区别</h2><p> (1)wait()是Object类的方法，sleep()是Thread类的方法</p><p>(2)wait()会释放锁，sleep()不会释放锁</p><p>(3)wait()要在同步方法或者同步代码块中执行，sleep()没有限制</p><p>(4)wait()要调用notify()或notifyall()唤醒,sleep()自动唤醒</p><h2 id="请你说说死锁定义及发生的条件-1"><a href="#请你说说死锁定义及发生的条件-1" class="headerlink" title="请你说说死锁定义及发生的条件"></a>请你说说死锁定义及发生的条件</h2><ol><li><p>两个或以上的线程在执行过程中争夺共享资源造成的一种互相等待对方的锁的现象,若无外力作用,他们都无法继续推进下去,此时这些互相等待的线程就称为死锁状态.</p></li><li><p>产生死锁的必要条件主要有四个: </p><ol><li><p><strong>互斥条件</strong>: 一个资源每次只能被一个线程使用 </p></li><li><p><strong>请求和保持条件</strong>: 一个线程在阻塞等待某个资源时，不释放已占有资源 </p></li><li><p><strong>不剥夺条件</strong>: 一个线程已经获得的资源，在未使用完之前，不能被强行剥夺 </p></li><li><p><strong>环路等待条件</strong>: 若干线程形成头尾相接的循环等待资源关系 这是造成死锁必须要达到的4个条件</p></li></ol><p>如果要避免死锁，只需要不满足其中某一个条件即可。而其中前3个条件是作为锁要符合的条件，所以要避免死锁就需要打破第4个条件，不出现循环等待锁的关系.</p></li></ol><h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><p>进程间通信方式主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket</p><h2 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h2><p>redis有五种基本数据类型和三种特殊的常用数据类型。 </p><p>基本数据类型： </p><p><strong>String</strong>:地城是一个动态字符串，支持扩容，存储字符串。</p><p><strong>list</strong>:存储有序可以重复的元素，底层数据结构是双向链表&#x2F;压缩链表。</p><p><strong>hash</strong>:存储的是键值对，底层是ziplist和hash </p><p><strong>set</strong>:存储不可重复的元素，底层数据结构可以是hash和整数数组。 </p><p><strong>zset</strong>:存储的是有序的不可重复的元素，底层是ziplist和跳表。 </p><p>特殊的数据类型： geo hyperloglog bitmap</p><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p><strong>乐观锁</strong>：总是假设最好的情况，就是在程序执行的过程中不会上锁，只有当更新修改的时候会判断一下在此期间有没有人更新了这个数据。可以使用版本号和CAS算法实现，适用多读。 </p><p><strong>悲观锁</strong>：悲观锁总是假设最坏的情况，每次去拿数据是都认为别人会修改，所以每次在拿数据时都会上锁，这样别人想拿这个数据时会阻塞直到拿到锁。mysql数据库的共享锁和排他锁都是悲观锁的实现。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>常用的设计模式有<strong>单例模式</strong>、<strong>工厂模式</strong>、<strong>代理模式</strong>、适配器模式、装饰器模式、模板方法模式等等。<strong>像sping中的定义的bean默认为单例模式</strong>，<strong>spring中的BeanFactory用来创建对象的实例，他是工厂模式的体现</strong>。AOP面向切面编程时代理模式的体现，它的底层就是基于动态代理实现的。适配器模式在springMVC中有体现，它的处理器适配器会根据处理器规则适配相应的处理器执行，模板方法模式用来解决代码重复的问题等</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式的含义：一个类仅有一个实例化对象，其最大特点是构造函数私有化。单例模式主要分为饿汉式，懒汉式，线程安全的懒汉式。其中饿汉式在类加载是就创建了实力对象，但是这样有可能造成资源的浪费；懒汉式，在类第一次被调用时创建实例，这样可能会造成线程安全问题；线程安全的懒汉式，则是在懒汉式的基础上加锁</p><p>懒汉式（线程安全）</p><pre class="line-numbers language-none"><code class="language-none">public class Singleton &#123;      private static Singleton instance;      private Singleton ()&#123;&#125;      public static synchronized Singleton getInstance() &#123;          if (instance &#x3D;&#x3D; null) &#123;              instance &#x3D; new Singleton();          &#125;          return instance;      &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>双检锁&#x2F;双重校验锁（DCL，即 double-checked locking）</p><pre class="line-numbers language-none"><code class="language-none">public class Singleton &#123;      private volatile static Singleton singleton;      private Singleton ()&#123;&#125;      public static Singleton getSingleton() &#123;      if (singleton &#x3D;&#x3D; null) &#123;          synchronized (Singleton.class) &#123;              if (singleton &#x3D;&#x3D; null) &#123;                  singleton &#x3D; new Singleton();              &#125;          &#125;      &#125;      return singleton;      &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>饿汉式</p><pre class="line-numbers language-none"><code class="language-none">public class Singleton &#123;      private static Singleton instance &#x3D; new Singleton();      private Singleton ()&#123;&#125;      public static Singleton getInstance() &#123;      return instance;      &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="什么是Spring？"><a href="#什么是Spring？" class="headerlink" title="什么是Spring？"></a>什么是Spring？</h2><p>Spring是个轻量级的框架，通过IOC达到松耦合的目的，通过AOP可以分离应用业务逻辑和系统服务进行内聚性的开发，不过配置各种组件时比较繁琐，所以后面才出选了SpringBoot的框架。 </p><h2 id="对MVC的理解"><a href="#对MVC的理解" class="headerlink" title="对MVC的理解"></a>对MVC的理解</h2><p>MVC是一种设计模式，将软件分为三层，分别是模型层（Model），视图层（View），控制器层（Controller）。其中模型层代表的是数据；视图层代表的是界面；控制器层代表的是逻辑处理，是连接视图与模型之前的桥梁。降低耦合，便于代码的维护。</p><h2 id="Aop的理解"><a href="#Aop的理解" class="headerlink" title="Aop的理解"></a>Aop的理解</h2><p>AOP面向切面编程。是spring两大核心之一，可以将那些与业务不相关但是很多业务都要调用的代码抽取出来，思想就是不侵入原有代码的情况下对功能进行增强。</p><h2 id="IOC的理解"><a href="#IOC的理解" class="headerlink" title="IOC的理解"></a>IOC的理解</h2><p>IOC：控制反转。将之前程序中需要手动创建对象的操作，交由 Spring 框架来实现，创建对象的操作被反转到了 Spring 框架。对 象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。</p><p>实现方式为DI依赖注入，有三种注入方式：构造器、setter、接口注入</p><hr><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="MySQL有哪些索引"><a href="#MySQL有哪些索引" class="headerlink" title="MySQL有哪些索引"></a>MySQL有哪些索引</h2><p>主键索引：一张表只能有一个主键索引，主键索引列不能有空值和重复值</p><p>唯一索引：唯一索引不能有相同值，但允许为空</p><p>普通索引：允许出现重复值</p><p>组合索引：对多个字段建立一个联合索引，减少索引开销，遵循最左匹配原则</p><p>全文索引：myisam引擎支持，通过建立倒排索引提升检索效率，广泛用于搜索引擎</p><h2 id="请你说说MySQL索引-以及它们的好处和坏处"><a href="#请你说说MySQL索引-以及它们的好处和坏处" class="headerlink" title="请你说说MySQL索引,以及它们的好处和坏处"></a>请你说说MySQL索引,以及它们的好处和坏处</h2><p>MySQL索引是一种帮助快速查找数据的数据结构，可以把它理解为书的目录，通过索引能够快速找到数据所在位置。常见的索引数据结构有：Hash表、二叉树</p><p>使用索引增加了数据查找的效率，但是相对的由于索引也需要存储到磁盘，所以增加了存储的压力，并且新增数据时需要同步维护索引。</p><h2 id="哪些情况索引会失效"><a href="#哪些情况索引会失效" class="headerlink" title="哪些情况索引会失效"></a>哪些情况索引会失效</h2><ol><li><p>where条件中有or，除非所有查询条件都有索引，否则失效</p></li><li><p>like查询用%开头，索引失效</p></li><li><p>索引列参与计算，索引失效</p></li><li><p>违背最左匹配原则，索引失效</p></li></ol><p>（5）索引字段发生类型转换，索引失效</p><p>（6）mysql觉得全表扫描更快时（数据少），索引失效</p><h2 id="说说MySQL的事务隔离级别"><a href="#说说MySQL的事务隔离级别" class="headerlink" title="说说MySQL的事务隔离级别"></a>说说MySQL的事务隔离级别</h2><p>在高并发情况下，并发事务会产生脏读、不可重复读、幻读问题，这时需要用隔离级别来控制</p><p>读未提交： 允许一个事务读取另一个事务已提交的数据，可能出现不可重复读，幻读。</p><p>读已提交：只允许事务读取另一个事务没有提交的数据可能出现不可重复读，幻读。</p><p>可重复读： 确保同一字段多次读取结果一致，可能出现欢幻读。</p><p>可串行化： 所有事务逐次执行，没有并发问题</p><h2 id="MySQL事务特性"><a href="#MySQL事务特性" class="headerlink" title="MySQL事务特性"></a>MySQL事务特性</h2><p>原子性：一个事务内的操作统一成功或失败</p><p>一致性：事务前后的数据总量不变</p><p>隔离性：事务与事务之间互相不影响</p><p>持久性：事务一旦提交，发生的改变不可变</p><hr><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="redis为什么快？"><a href="#redis为什么快？" class="headerlink" title="redis为什么快？"></a>redis为什么快？</h2><ol><li><p>完全基于内存操作，数据都存在内存中</p></li><li><p>采用单线程，避免了不必要的上下文切换带来的性能问题，也不用考虑锁的问题</p></li><li><p>基于非阻塞的io多路复用机制</p></li><li><p>数据结构简单，对数据操作简单</p></li></ol><h2 id="说说Redis的数据类型"><a href="#说说Redis的数据类型" class="headerlink" title="说说Redis的数据类型"></a>说说Redis的数据类型</h2><p>redis中常用的五种数据结构：<strong>string</strong>、<strong>list</strong>、<strong>set</strong>、<strong>zset</strong>、<strong>hash</strong>。</p><ul><li>String结构底层是一个简单动态字符串，支持扩容，存储字符串。</li><li>list存储线性有序且可重复的元素，底层数据结构可以是双向链表&#x2F;压缩列表。</li><li>set存储不可重复的元素，底层数据结构可以是hash和整数数组。</li><li>zset存储的是有序不可重复的元素，zset为每个元素添加了一个score属性作为排序依据，底层数据结构可以是ziplist和跳表。</li><li>hash类型存储的是键值对，底层数据结构是ziplist和hash。</li></ul><p>redis会在性能以及节省内存间考虑，选择最适合当前状态的底层数据结构实现</p><h2 id="Redis的持久化策略"><a href="#Redis的持久化策略" class="headerlink" title="Redis的持久化策略"></a>Redis的持久化策略</h2><p>Redis的持久化方式有两种：快照持久化RDB（redis database ）和追加持久化AOF（append only file）</p><p>RDB：Redis的默认持久化机制，在指定时间间隔内将内存中的数据集快照写入磁盘 </p><p>AOF：以日志的形式记录每个写入和删除操作操作，这样在redis崩溃重启时，会读取.aof文件并重新执行一遍，以此来恢复数据， 优先级AOF&gt;RDB</p><h2 id="Redis缓存穿透如何解决？"><a href="#Redis缓存穿透如何解决？" class="headerlink" title="Redis缓存穿透如何解决？"></a>Redis缓存穿透如何解决？</h2><p>缓存穿透是指频繁请求客户端和缓存中都不存在的数据，缓存永远不生效，请求都到达了数据库。</p><p>解决方案：</p><ol><li><p>在接口上做基础校验，比如id&lt;&#x3D;0就拦截</p></li><li><p>缓存空对象：找不到的数据也缓存起来，并设置过期时间，可能会造成短期不一致</p></li><li><p>布隆过滤器：在客户端和缓存之间添加一个过滤器，拦截掉一定不存在的数据请求</p></li></ol><h2 id="Redis如何解决缓存击穿？"><a href="#Redis如何解决缓存击穿？" class="headerlink" title="Redis如何解决缓存击穿？"></a>Redis如何解决缓存击穿？</h2><p>缓存击穿是指一个非常热点key，在某一瞬间失效，导致大量请求到达数据库</p><p>解决方案：</p><ol><li><p>设置热点数据永不过期</p></li><li><p>给缓存重建的业务加上互斥锁，缺点是性能低</p></li></ol><h2 id="Redis如何解决缓存雪崩？"><a href="#Redis如何解决缓存雪崩？" class="headerlink" title="Redis如何解决缓存雪崩？"></a>Redis如何解决缓存雪崩？</h2><p>缓存雪崩是值某一时间大量Key同时失效或redis宕机，导致大量请求到达数据库</p><p>解决方案：</p><ol><li><p>搭建集群保证高可用</p></li><li><p>进行数据预热，给不同的key设置随机的过期时间</p></li><li><p>给缓存业务添加限流降级，通过加锁或队列控制操作redis的线程数量</p></li><li><p>给业务添加多级缓存</p></li></ol><h2 id="Redis如何实现key的过期删除？"><a href="#Redis如何实现key的过期删除？" class="headerlink" title="Redis如何实现key的过期删除？"></a>Redis如何实现key的过期删除？</h2><p>采用的定期删除+惰性删除</p><p>定期删除：Redis每隔一段时间从设置过期时间的key集合中，随机抽取一些key，检查是否过期，如过期做删除处理；</p><p>惰性删除：Redis在key被访问的时候检查key是否过期，如果过期则删除；</p><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="SpringCloud常见组件有哪些"><a href="#SpringCloud常见组件有哪些" class="headerlink" title="SpringCloud常见组件有哪些"></a>SpringCloud常见组件有哪些</h2><ul><li>注册中心组件：Nacos、Eureka</li><li>负载均衡组件：Ribbon</li><li>远程调用组件： OpenFeign</li><li>网关组件：Gateway、Zuul</li><li>服务保护组件：Hystrix、Sentinel</li><li>服务配置管理组件：Nacos、SpringCloudConfig</li></ul>]]></content>
      
      
      <categories>
          
          <category> -笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地文件用git上传到gitee</title>
      <link href="/2022/09/19/%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E7%94%A8git%E4%B8%8A%E4%BC%A0%E5%88%B0gitee/"/>
      <url>/2022/09/19/%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E7%94%A8git%E4%B8%8A%E4%BC%A0%E5%88%B0gitee/</url>
      
        <content type="html"><![CDATA[<h1 id="本地文件用git上传到gitee"><a href="#本地文件用git上传到gitee" class="headerlink" title="本地文件用git上传到gitee"></a>本地文件用git上传到gitee</h1><h2 id="1-首先要在gitee上建一个仓库"><a href="#1-首先要在gitee上建一个仓库" class="headerlink" title="1. 首先要在gitee上建一个仓库"></a>1. 首先要在gitee上建一个仓库</h2><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgfd2d2a1140b143dda8c77ee53f31913b.png" alt="img"></p><h2 id="2-进行初始化"><a href="#2-进行初始化" class="headerlink" title="2.进行初始化"></a>2.进行初始化</h2><p>进入到要上传文件的目录，右键选中Git Bash Here进入git命令行，输入</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgfb3867cc6e0f4543ae20c3ec07bda60b.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-none"><code class="language-none">git init&#x2F;&#x2F;进行初始化，会在目录下创建一个.git的本地仓库<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-配置目标仓库地址（要上传的仓库地址）"><a href="#3-配置目标仓库地址（要上传的仓库地址）" class="headerlink" title="3. 配置目标仓库地址（要上传的仓库地址）"></a>3. 配置目标仓库地址（要上传的仓库地址）</h2><p>先复制目标仓库地址：</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimage-20221005102957572.png" alt="image-20221005102957572"></p><p>输入如下命令，将本地仓库与远程仓库相关联：</p><pre class="line-numbers language-none"><code class="language-none">git remote add origin https:&#x2F;&#x2F;... &#x2F;仓库名.git   &#x2F;&#x2F;后面改为你自己刚复制的仓库地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-与仓库的文件进行同步"><a href="#4-与仓库的文件进行同步" class="headerlink" title="4. 与仓库的文件进行同步"></a>4. 与仓库的文件进行同步</h2><pre class="line-numbers language-none"><code class="language-none">git pull --rebase origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-将要上传的文件放入此文件夹后再添加到缓冲区"><a href="#5-将要上传的文件放入此文件夹后再添加到缓冲区" class="headerlink" title="5. 将要上传的文件放入此文件夹后再添加到缓冲区"></a>5. 将要上传的文件放入此文件夹后再添加到缓冲区</h2><pre class="line-numbers language-none"><code class="language-none">git add .&#x2F;&#x2F;添加当前目录下的所有文件到<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6-将文件提交到本地"><a href="#6-将文件提交到本地" class="headerlink" title="6. 将文件提交到本地"></a>6. 将文件提交到本地</h2><pre class="line-numbers language-none"><code class="language-none">git commit -m &#39;dubbo-admin&#39;&#x2F;&#x2F;单引号内的内容为提交时的备注信息<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7-推送到GItee仓库中"><a href="#7-推送到GItee仓库中" class="headerlink" title="7.推送到GItee仓库中"></a>7.推送到GItee仓库中</h2><pre class="line-numbers language-none"><code class="language-none">git push origin master&#x2F;&#x2F;master是默认分支名，这里可以根据自己需要进行修改<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="8-登录gitee远程仓库查看，成功上传"><a href="#8-登录gitee远程仓库查看，成功上传" class="headerlink" title="8.登录gitee远程仓库查看，成功上传"></a>8.登录gitee远程仓库查看，成功上传</h2>]]></content>
      
      
      <categories>
          
          <category> -教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis主从复制原理和用法</title>
      <link href="/2022/09/18/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%92%8C%E7%94%A8%E6%B3%95/"/>
      <url>/2022/09/18/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%92%8C%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="1、是什么"><a href="#1、是什么" class="headerlink" title="1、是什么"></a>1、是什么</h2><ul><li>主机数据更新后根据配置和策略， 自动同步到备机的master&#x2F;slaver机制，Master以写为主，Slave以读为主</li></ul><h2 id="2、能干什么"><a href="#2、能干什么" class="headerlink" title="2、能干什么"></a>2、能干什么</h2><ul><li>读写分离，性能扩展</li><li>容灾快速恢复</li></ul><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimage-20220919163222071.png" alt="image-20220919163222071"></p><h2 id="3、主从复制原理"><a href="#3、主从复制原理" class="headerlink" title="3、主从复制原理"></a>3、主从复制原理</h2><p>1、当从连接上主服务器之后,从服务器向主服务发送进行数据同步消息</p><p>2、主服务器接到从服务器发送过来同步消息,把主服务器数据进行持久化，rdb文件，把rdb文件发送从服务器，从服务器拿到rdb进行读取</p><p>3、每次主服务器进行写操作之后，和从服务器进行数据同步</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimg1621664167220-774ddca2-d714-472d-84ae-2242450a53be.png" alt="image.png"></p><h2 id="4、环境配置"><a href="#4、环境配置" class="headerlink" title="4、环境配置"></a>4、环境配置</h2><ul><li><p>新建myredis目录</p><pre class="line-numbers language-none"><code class="language-none">[root@a etc]# mkdir myredis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制一份<code>redis.conf</code>到myredis目录（etc目录下复制过redis.conf， 如果没有就去安装目录复制）</p><pre class="line-numbers language-none"><code class="language-none">[root@a etc]# cp redis.conf myredis&#x2F;redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改myredis目录下<code>redis.conf</code>，将daemonize设置为yes，Appendonly 关掉myredis目录下新建<code>redis6379.conf</code> </p><pre class="line-numbers language-none"><code class="language-none">[root@a myredis]# vi redis6379.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>并添加内容</p><pre class="line-numbers language-none"><code class="language-none">include redis.confpidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pidport 6379dbfilename dump6379.rdb <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>myredis目录下新建<code>redis6380.conf</code> </p><pre class="line-numbers language-none"><code class="language-none">[root@a myredis]# vi redis6380.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>并添加内容</p><pre class="line-numbers language-none"><code class="language-none">include redis.confpidfile &#x2F;var&#x2F;run&#x2F;redis_6380.pidport 6380dbfilename dump6380.rdb <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>myredis目录下新建<code>redis6381.conf</code> </p><pre class="line-numbers language-none"><code class="language-none">[root@a myredis]# vi redis6381.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>并添加内容</p><pre class="line-numbers language-none"><code class="language-none">include redis.confpidfile &#x2F;var&#x2F;run&#x2F;redis_6381.pidport 6381dbfilename dump6381.rdb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>关闭以前启动的redis服务</p><pre class="line-numbers language-none"><code class="language-none">ps -ef | grep redis  kill 端口号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>使用三个配置文件分别启动redis，并打开server-cli</p><pre class="line-numbers language-none"><code class="language-none">[root@a myredis]# redis-server redis6379.conf（启动redis）[root@a myredis]# redis-cli -p 6379（打开server-cli）127.0.0.1:6379&gt; info replication（查看主从复制的相关信息）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">[root@a myredis]# redis-server redis6380.conf[root@a myredis]# redis-cli -p 6380127.0.0.1:6380&gt; info replication<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">[root@a myredis]# redis-server redis6381.conf[root@a myredis]# redis-cli -p 6381127.0.0.1:6381&gt; info replication<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>配从库而不配主库，分别在从库中设置主从信息，选取6379为主库</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6380&gt;  slaveof 127.0.0.1 6379<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6381&gt;  slaveof 127.0.0.1 6379<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>PS：</strong></p><blockquote><p>从机只能读数据而不能写数据</p><p>主机挂掉，重启就行，主从配置不会失效</p><p>从机重启需重设：<code>slaveof 127.0.0.1 6379 </code></p><p>可以将配置增加到文件中。永久生效。</p></blockquote><h2 id="5、一主二从"><a href="#5、一主二从" class="headerlink" title="5、一主二从"></a>5、一主二从</h2><ul><li>主机宕机后，从机原地待命，不会成为主机</li><li>从机宕机后，重启后需要重新设置主机IP</li><li>从机宕机后，重新挂到主机上，会将主机的数据从头开始复制</li></ul><h2 id="6、薪火相传"><a href="#6、薪火相传" class="headerlink" title="6、薪火相传"></a>6、薪火相传</h2><ul><li>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</li><li>用 <code>slaveof &lt;ip&gt; &lt;port&gt;</code></li><li>中途变更转向：会清除之前的数据，重新建立拷贝最新的</li><li>风险是一旦某个slave宕机，后面的slave都没法备份</li><li>主机挂了，从机还是从机，无法写数据了</li></ul><h2 id="7、反客为主"><a href="#7、反客为主" class="headerlink" title="7、反客为主"></a>7、反客为主</h2><ul><li>当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。</li><li>用 <code>slaveof no one</code>  将从机变为主机。</li></ul><h2 id="9、复制原理"><a href="#9、复制原理" class="headerlink" title="9、复制原理"></a>9、复制原理</h2><ul><li>Slave启动成功连接到master后会发送一个sync命令</li><li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li><li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li><li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li></ul>]]></content>
      
      
      <categories>
          
          <category> -笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis哨兵模式</title>
      <link href="/2022/09/18/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/18/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><ul><li><strong>反客为主（当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。）</strong>的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</li></ul><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimage-20220919170850430-16635785371291.png" alt="image-20220919170850430"></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li><p>调整为一主二仆模式，6379带着6380、6381</p></li><li><p>自定义的<code>/myredis</code>目录下新建<code>sentinel.conf</code>文件，<strong>名字绝不能错</strong></p><pre class="line-numbers language-none"><code class="language-none">[root@a myredis]# vi sentinel.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>配置哨兵</p><pre class="line-numbers language-none"><code class="language-none">sentinel monitor mymaster 127.0.0.1 6379 1PS: 其中mymaster为监控对象自定义的服务器名称， 1 为至少有多少个哨兵(启动的sentinel)同意从机切换为主机。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>启动哨兵</p><pre class="line-numbers language-none"><code class="language-none">[root@a myredis]# redis-sentinel  &#x2F;myredis&#x2F;sentinel.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p><code>当主机挂掉，在从机中产生新的主机。原主机重启后会变为从机（根据优先级别：slave-priority ），原主机重启后会变为从机。</code></p><h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimage-20220919172021991-16635792291332.png" alt="image-20220919172021991"></p><ul><li>优先级在redis.conf中默认：slave-priority 100，值越小优先级越高</li><li>偏移量是指获得原主机数据最全的</li><li>每个redis实例启动后都会随机生成一个40位的runid</li></ul><h2 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h2><ul><li>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</li></ul>]]></content>
      
      
      <categories>
          
          <category> -笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统下安装MySQL</title>
      <link href="/2022/09/18/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/"/>
      <url>/2022/09/18/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/</url>
      
        <content type="html"><![CDATA[<p><strong>1 查看是否已经安装 Mysql</strong></p><pre class="line-numbers language-none"><code class="language-none">rpm -qa | grep mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你查看出来有东西，可以使用下面命令将其删除</p><pre class="line-numbers language-none"><code class="language-none">rpm -e 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2 下载官方 Mysql 包</strong></p><pre class="line-numbers language-none"><code class="language-none">wget -i -c http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-10.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimage-20221008163223422.png" alt="image-20221008163223422"></p><blockquote><p>如果安装有提示：Cannot write to ‘mysql57-community-release-el7-10.noarch.rpm’ (No such file or directory)，那就是权限不够</p><p>可以输入 su root 来解决，然后重新下载。</p></blockquote><p><strong>3 安装MySQL包</strong></p><pre class="line-numbers language-none"><code class="language-none">yum -y install mysql57-community-release-el7-10.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>4 安装 MySQL</strong></p>  <pre class="line-numbers language-none"><code class="language-none">yum -y install mysql-community-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果执行命令过程中提示：Unable to find a match: mysql-community-server</p><p>则可以通过命令解决</p><pre class="line-numbers language-none"><code class="language-none">yum module disable mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>5启动 Mysql 服务</strong></p><pre class="line-numbers language-none"><code class="language-none">systemctl start mysqld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有报错，进入第六步，</p><p>如果执行报错，多半是没有权限，执行下面语句赋予权限，然后重试</p><pre class="line-numbers language-none"><code class="language-none">chown mysql:mysql -R &#x2F;var&#x2F;lib&#x2F;mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>6 查看 Mysql 运行状态</strong></p><pre class="line-numbers language-none"><code class="language-none">service mysqld status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看见这个绿色就表示启动成功了</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimage-20221008170143562.png" alt="image-20221008170143562"></p><p><strong>7 查看初始密码（红色部分为初始密码)</strong></p> <pre class="line-numbers language-none"><code class="language-none">grep ‘password’ &#x2F;var&#x2F;log&#x2F;mysqld.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果能正常查看到，则OK；如果查看不到，则表示没有密码。</p><p><strong>8 进入数据库</strong></p><pre class="line-numbers language-none"><code class="language-none">mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入命令后，点击回车，会让你输入密码，然后输入刚刚的初始密码（输密码的时候不可见），当然支持粘贴，你可以复制初始密码后，然后粘贴。如果没有密码，直接回车即可。</p><p><strong>注: 如果显示数据库无法访问</strong></p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimage-20221008170457217.png" alt="image-20221008170457217"></p><p>修改文件之前记得先关闭mysql服务</p><pre class="line-numbers language-none"><code class="language-none">service mysqld stop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改MySql配置文件my.cnf，新增skip-grant-tables</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F; -name my.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimage-20221008170746871.png" alt="image-20221008170746871"></p><p>通过 vi 指令进入文件</p><pre class="line-numbers language-none"><code class="language-none">vi &#x2F;etc&#x2F;my.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimage-20221008170833326.png" alt="image-20221008170833326"></p><p>新增skip-grant-tables ,添加skip-grant-tables，这样mysql可以免密登录。</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimage-20221008171121621.png" alt="image-20221008171121621"></p><p>重启服务</p><pre class="line-numbers language-none"><code class="language-none">service mysqld start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再次连接MySql，重置密码</p><p>任意密码就可以进入了</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimage-20221008171406615.png" alt="image-20221008171406615"></p><p>通过 show databases; 注意带 ; 号</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimage-20221008171433125.png" alt="image-20221008171433125"></p><p><strong>切换到mysql数据库</strong>，<strong>重置密码（为 root ）</strong></p><pre class="line-numbers language-none"><code class="language-none">update user set authentication_string&#x3D;password(&#39;root&#39;) where user&#x3D;&#39;root&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改配置文件my.cnf，删除skip-grant-tables，重启，再登录</p><p>删除skip-grant-tables</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimage-20221008171623784.png" alt="image-20221008171623784"></p><p>重启服务</p><pre class="line-numbers language-none"><code class="language-none">service mysqld start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据指令进入MySQL数据库</p><pre class="line-numbers language-none"><code class="language-none">mysql -uroot -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再次使用新密码登录即可至此！</p>]]></content>
      
      
      <categories>
          
          <category> -教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群</title>
      <link href="/2022/09/18/Redis%E9%9B%86%E7%BE%A4/"/>
      <url>/2022/09/18/Redis%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h2 id="什么是集群"><a href="#什么是集群" class="headerlink" title="什么是集群"></a>什么是集群</h2><ul><li>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1&#x2F;N。</li><li>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</li></ul><h2 id="环境配置（阿里云版）"><a href="#环境配置（阿里云版）" class="headerlink" title="环境配置（阿里云版）"></a>环境配置（阿里云版）</h2><ul><li><p>开启daemonize yes</p></li><li><p>Appendonly 关掉或者换名字</p></li><li><p>cluster-enabled yes    打开集群模式</p></li><li><p>cluster-config-file nodes-6379.conf  设定节点配置文件名</p></li><li><p>cluster-node-timeout 15000   设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</p></li><li><p>将myredis目录下的所有dump文件删除</p><pre class="line-numbers language-none"><code class="language-none">rm -rf dump*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建六个redis配置文件</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621680889251-5cac6704-619e-405a-a311-c545c1d8c4f0.png" alt="image.png"></p></li><li><p>每个文件的内容分别为</p><ul><li><p><code>redis6379.conf</code></p><pre class="line-numbers language-none"><code class="language-none">include redis.confpidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pidport 6379dbfilename dump6379.rdbcluster-enabled yes    (打开集群模式)cluster-config-file nodes-6379.conf (设定节点配置文件名)cluster-node-timeout 15000(设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>redis6380.conf</code></p><pre class="line-numbers language-none"><code class="language-none">include redis.confpidfile &#x2F;var&#x2F;run&#x2F;redis_6380.pidport 6380dbfilename dump6380.rdbcluster-enabled yescluster-config-file nodes-6380.confcluster-node-timeout 15000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>redis6381.conf</code></p><pre class="line-numbers language-none"><code class="language-none">include redis.confpidfile &#x2F;var&#x2F;run&#x2F;redis_6381.pidport 6381dbfilename dump6381.rdbcluster-enabled yescluster-config-file nodes-6381.confcluster-node-timeout 15000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>redis6389.conf</code></p><pre class="line-numbers language-none"><code class="language-none">include redis.confpidfile &#x2F;var&#x2F;run&#x2F;redis_6389.pidport 6389dbfilename dump6389.rdbcluster-enabled yescluster-config-file nodes-6389.confcluster-node-timeout 15000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>redis6390.conf</code></p><pre class="line-numbers language-none"><code class="language-none">include redis.confpidfile &#x2F;var&#x2F;run&#x2F;redis_6390.pidport 6390dbfilename dump6390.rdbcluster-enabled yescluster-config-file nodes-6390.confcluster-node-timeout 15000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>redis6391.conf</code></p><pre class="line-numbers language-none"><code class="language-none">include redis.confpidfile &#x2F;var&#x2F;run&#x2F;redis_6391.pidport 6391dbfilename dump6391.rdbcluster-enabled yescluster-config-file nodes-6391.confcluster-node-timeout 15000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>阿里云控制台添加安全组</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621681530918-b8cec623-b633-4985-8b44-78e61c33fb7e.png" alt="image.png"></p><p><code>PS ： 安全组的创建百度即可，注意安全组所属地区是否与你的服务器所在地区一致</code></p></li><li><p>使用六个配置文件启动六个redis-server</p><pre class="line-numbers language-none"><code class="language-none">[root@a myredis]# redis-server redis6379.conf[root@a myredis]# redis-server redis6380.conf[root@a myredis]# redis-server redis6381.conf[root@a myredis]# redis-server redis6389.conf[root@a myredis]# redis-server redis6390.conf[root@a myredis]# redis-server redis6391.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621681860617-14239187-ba4d-4e9e-9c80-9581c9a7f4ba.png" alt="image.png"></p></li><li><p>确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621681981375-3e5c793c-38c2-4cc2-8677-a93c3a96f746.png" alt="image.png"></p></li><li><p>进入下载的redis目录</p><pre class="line-numbers language-none"><code class="language-none">cd &#x2F;opt&#x2F;redis-6.2.3&#x2F;src<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使用 redis-cli 创建整个 redis 集群（redis5.0版本之前使用的ruby脚本 redis-trib.rb，之后的版本已经集成该脚本）</p><pre class="line-numbers language-none"><code class="language-none">redis-cli --cluster create --cluster-replicas 1 8.129.52.78:6379 8.129.52.78:6380 8.129.52.78:6381 8.129.52.78:6389 8.129.52.78:6390 8.129.52.78:6391<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>此处不要用127.0.0.1，请用真实IP地址，即服务器IP地址</p><p>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</p></blockquote><p>成功示例：<img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621682648692-dea7f4e8-c61d-4fad-9cec-880ce4c83bd4.png" alt="image.png"></p></li></ul><h2 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h2><ul><li><p>-c 采用集群策略连接，设置数据会自动切换到相应的写主机</p><pre class="line-numbers language-none"><code class="language-none">[root@a src]#  redis-cli -c -p 6379<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>通过 cluster nodes 命令查看集群信息</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; cluster nodes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621683570035-b8d06dd5-7d0c-4f97-8f45-675bc649810a.png" alt="image.png"></p></li></ul><h2 id="cluster-如何分配当前六个节点"><a href="#cluster-如何分配当前六个节点" class="headerlink" title="cluster 如何分配当前六个节点"></a>cluster 如何分配当前六个节点</h2><ul><li>一个集群至少要有三个主节点。</li><li>选项–cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</li><li>分配原则尽量保证每个主数据库运行在不同的IP地址(即不同的服务器)，每个从库和主库不在一个IP地址上。</li></ul><h2 id="什么是slots"><a href="#什么是slots" class="headerlink" title="什么是slots"></a>什么是slots</h2><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621684958986-2d20ce93-69c7-4417-bc86-7041b232bde0.png" alt="image.png"></p><p>一个 Redis 集群包含16384 个插槽（hash slot），数据库中的每个键都属于这16384 个插槽的其中一个，集群使用公式CRC16(key) % 16384 来计算键key 属于哪个槽，其中CRC16(key) 语句用于计算键key 的CRC16 校验和。集群中的每个节点负责处理一部分插槽。</p><p>举个例子，一个集群有三个主节点，其中：</p><p>节点 A 负责处理0号至5460号插槽。</p><p>节点 B 负责处理5461号至10922号插槽。</p><p>节点 C 负责处理10923号至16383号插槽。</p><h2 id="向集群写值"><a href="#向集群写值" class="headerlink" title="向集群写值"></a>向集群写值</h2><ul><li>计算出slot后，自动重定向到对应集群节点</li></ul><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621685492492-99d957f7-d747-4817-a3b1-f4d119cee03a.png" alt="image.png"></p><ul><li>通过{}定义组才可以使用mget,mset等多键操作</li></ul><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621685670270-eb8a87d0-2a50-4cb6-a1fe-18b7064d6359.png" alt="image.png"></p><h2 id="查询集群中的值"><a href="#查询集群中的值" class="headerlink" title="查询集群中的值"></a>查询集群中的值</h2><ul><li><p><code>cluster keyslot &lt;key&gt; </code>：计算键 key 应该被放置在哪个槽上</p><pre class="line-numbers language-none"><code class="language-none">cluster keyslot k1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><img src="E:/Java%E7%AC%94%E8%AE%B0/Images/%E5%A4%87%E4%BB%BD%E7%9A%84%E5%9B%BE%E7%89%87/img1621685919817-de794104-a464-4078-9da0-6d5ef962ac63-16636409287187.png" alt="image.png"></p><ul><li><code>cluster countkeysinslot &lt;slot&gt;</code> ：返回槽 slot 目前包含的键值对数量。（槽slot的值必须在当前节点范围内否则返回0）</li></ul><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621686622168-cba72737-5119-42e2-b599-0a57143969e3.png" alt="image.png"></p><ul><li><p><code>cluster getkeysinslot &lt;slot&gt; &lt;count&gt;</code> ：返回 count 个 slot 槽中的键 （槽slot的值必须在当前节点范围内否则返回empty array）</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621686735935-bb17e993-27bd-4303-b693-2e7b51e44120.png" alt="image.png"></p></li></ul><h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><ul><li>某台主机(A)宕机后，它的从机(B)就会成为主机(C)，且再次启动宕机的主机(A)，该主机(A)会变成C的从机</li><li>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么，整个集群都挂掉</li><li>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</li><li>redis.conf中的参数  cluster-require-full-coverage</li></ul><h2 id="集群好处与不足"><a href="#集群好处与不足" class="headerlink" title="集群好处与不足"></a>集群好处与不足</h2><ul><li><p>好处</p><ul><li><p>实现扩容</p></li><li><p>分摊压力</p></li><li><p>无中心配置相对简单</p></li></ul></li><li><p>不足</p><ul><li><p>多键操作是不被支持的</p></li><li><p>多键的Redis事务是不被支持的。lua脚本不被支持</p></li><li><p>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> -笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis应用问题（缓存穿透、缓存击穿、缓存雪崩和分布式锁）</title>
      <link href="/2022/09/18/Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/18/Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis高并发场景应用问题"><a href="#Redis高并发场景应用问题" class="headerlink" title="Redis高并发场景应用问题"></a>Redis高并发场景应用问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>key对应的数据在数据源并不存在，此时若有大量并发请求过来，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621733790830-d7ffc000-0f06-4e07-8149-08495a1fb8a9.png" alt="image.png"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p><p>解决问题：</p><ul><li><strong>对空值缓存</strong>：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</li><li><strong>设置可访问的名单</strong>（白名单）：使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</li><li><strong>采用布隆过滤器</strong>：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</li><li><strong>进行实时监控</strong>：当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>key(某个)对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621734025111-91bbf46d-2bef-4429-b83d-8de010ebaadf.png" alt="image.png"></p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p><p>解决问题：</p><ul><li><p>预先设置热门数据：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</p></li><li><p>实时调整：现场监控哪些数据热门，实时调整key的过期时长</p></li><li><p>使用锁：</p></li><li><ul><li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</li><li>先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</li><li>当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</li></ul></li></ul><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621734045867-7a718986-99c5-4686-b4ee-b31d1e4ef69b.png" alt="image.png"></p><hr><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>大量的key对应的数据存在，但key在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p><code>PS.缓存雪崩与缓存击穿的区别在于缓存雪崩针对很多key缓存，缓存击穿则是某一个key</code></p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕！</p><p>解决方案：</p><ul><li>构建多级缓存架构：nginx缓存 + redis缓存 +其他缓存（ehcache等）</li><li>使用锁或队列：用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</li><li>设置过期标志更新缓存：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</li><li>将缓存失效时间分散开：比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li></ul><hr><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p><p>分布式锁主流的实现方案：</p><ol><li><ol><li><ol><li>基于数据库实现分布式锁</li><li>基于缓存（Redis等）</li><li>基于Zookeeper</li></ol></li></ol></li></ol><p>每一种分布式锁解决方案都有各自的优缺点：</p><ol><li><ol><li><ol><li>性能：redis最高</li><li>可靠性：zookeeper最高</li></ol></li></ol></li></ol><p>这里我们就基于redis实现分布式锁。</p><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>redis命令（setnx）</p><ul><li><p>setnx加锁，del释放锁</p><blockquote><ul><li>加锁：<code>setnx user niubi</code></li><li>释放锁: <code>del user</code></li></ul><p><strong>问题</strong>：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放</p><p><strong>解决</strong>：设置过期时间，自动释放锁。</p></blockquote></li><li><p>设置过期时间防止锁一直不被释放</p><blockquote><ul><li><p>加锁：<code>setnx user niubi</code></p></li><li><p>设置过期：<code>expire user 10</code></p></li></ul><p><strong>缺乏原子性</strong>：如果在setnx和expire之间出现异常，锁也无法释放</p></blockquote></li><li><p>同时设置锁和过期时间(推荐使用)</p><blockquote><ul><li><code>set user 10 nx ex 10</code></li></ul><p><strong>问题</strong>：可能会释放其他服务器的锁。</p><p><strong>场景</strong>：如果业务逻辑的执行时间是7s，锁过期时间为3s。执行流程如下</p><ol><li>index1业务逻辑没执行完，3秒后锁被自动释放。</li><li>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</li><li>index3获取到锁，执行业务逻辑</li><li>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行    1s就被别人释放。</li><li>最终等于没锁的情况。</li></ol><p><strong>解决</strong>：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p></blockquote></li><li><p>设置UUID防误删(即将key的值设置为唯一值)</p><blockquote><ul><li><code>set user UUID nx ex 10</code></li></ul><p><strong>问题</strong>：删除操作缺乏原子性。</p><p><strong>场景</strong>：</p><ol><li>index1执行删除时，查询到的lock值确实和uuid相等</li><li>index1执行删除前，lock刚好过期时间已到，被redis自动释放</li><li>index2获取了lock开始执行方法</li><li>index1执行删除，此时会把index2的lock删除  （同一个锁）</li></ol><p>index1 因为已经在方法中了，所以不需要重新上锁。index1有执行的权限。</p><p><strong>解决</strong>：LUA脚本保证删除的原子性</p></blockquote></li><li><p>set 命令参数详解</p><blockquote><p>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value </p><p>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于PSETEX key millisecond value 。</p><p>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</p><p>XX ：只在键已经存在时，才对键进行设置操作。</p></blockquote></li></ul><hr><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ol><li>setnx加锁，del释放锁</li></ol><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621736779482-c68c8249-40e3-475e-86a7-ba049a9c4e45.png" alt="image.png"></p><pre class="line-numbers language-none"><code class="language-none">@GetMapping(&quot;testLock&quot;)public void testLock()&#123;    &#x2F;&#x2F;1获取锁，setnx--&gt;setIfAbsent    Boolean lock &#x3D; redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;111&quot;);    &#x2F;&#x2F;2获取锁成功、查询num的值    if(lock)&#123;        Object value &#x3D; redisTemplate.opsForValue().get(&quot;num&quot;);        &#x2F;&#x2F;2.1判断num为空return        if(StringUtils.isEmpty(value))&#123;            return;        &#125;        &#x2F;&#x2F;2.2有值就转成成int        int num &#x3D; Integer.parseInt(value+&quot;&quot;);        &#x2F;&#x2F;2.3把redis的num加1        redisTemplate.opsForValue().set(&quot;num&quot;, ++num);        &#x2F;&#x2F;2.4释放锁，del        redisTemplate.delete(&quot;lock&quot;);    &#125;else&#123;        &#x2F;&#x2F;3获取锁失败、每隔0.1秒再获取        try &#123;            Thread.sleep(100);            testLock();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ol><li><p>多个客户端同时获取锁（setnx）</p></li><li><p>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p></li><li><p>其他客户端等待重试</p></li></ol></blockquote><ol start="2"><li><p>同时设置锁和过期时间(推荐使用)</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621737077357-6f47c76e-8d16-4e46-b661-4845584cdf87.png" alt="image.png"></p></li></ol><pre class="line-numbers language-none"><code class="language-none">@GetMapping(&quot;testLock&quot;)public void testLock()&#123;    &#x2F;&#x2F;1获取锁，setnx--&gt;setIfAbsent    Boolean lock &#x3D; redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;111&quot;, 10, TimeUnit.SECONDS);    &#x2F;&#x2F;2获取锁成功、查询num的值    if(lock)&#123;        Object value &#x3D; redisTemplate.opsForValue().get(&quot;num&quot;);        &#x2F;&#x2F;2.1判断num为空return        if(StringUtils.isEmpty(value))&#123;            return;        &#125;        &#x2F;&#x2F;2.2有值就转成成int        int num &#x3D; Integer.parseInt(value+&quot;&quot;);        &#x2F;&#x2F;2.3把redis的num加1        redisTemplate.opsForValue().set(&quot;num&quot;, ++num);        &#x2F;&#x2F;2.4释放锁，del，保证锁必须被释放        redisTemplate.delete(&quot;lock&quot;);  --&gt;当业务执行时间小与过期时间时需要释放锁    &#125;else&#123;        &#x2F;&#x2F;3获取锁失败、每隔0.1秒再获取        try &#123;            Thread.sleep(100);            testLock();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>设置UUID防误删</li></ol><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img1621745985222-091ca300-14fa-4b32-bdba-f7a611075147.png" alt="image.png"></p><pre class="line-numbers language-none"><code class="language-none">@GetMapping(&quot;testLock&quot;)public void testLock()&#123;    &#x2F;&#x2F;1获取锁，setnx--&gt;setIfAbsent    String uuid &#x3D; UUID.randomUUID().toString();    Boolean lock &#x3D; redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, uuid, 10, TimeUnit.SECONDS);    &#x2F;&#x2F;2获取锁成功、查询num的值    if(lock)&#123;        Object value &#x3D; redisTemplate.opsForValue().get(&quot;num&quot;);        &#x2F;&#x2F;2.1判断num为空return        if(StringUtils.isEmpty(value))&#123;            return;        &#125;        &#x2F;&#x2F;2.2有值就转成成int        int num &#x3D; Integer.parseInt(value+&quot;&quot;);        &#x2F;&#x2F;2.3把redis的num加1        redisTemplate.opsForValue().set(&quot;num&quot;, ++num);        &#x2F;&#x2F;2.4释放锁，del，保证锁必须被释放--&gt;当业务执行时间小与过期时间时需要释放锁        if(uuid.equals((String)redisTemplate.opsForValue().get(&quot;lock&quot;)))&#123;             redisTemplate.delete(&quot;lock&quot;); --&gt;删除自己的锁        &#125;    &#125;else&#123;        &#x2F;&#x2F;3获取锁失败、每隔0.1秒再获取        try &#123;            Thread.sleep(100);            testLock();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>LUA脚本保证删除的原子性</li></ol><pre class="line-numbers language-none"><code class="language-none">@GetMapping(&quot;testLockLua&quot;)public void testLockLua() &#123;    &#x2F;&#x2F;1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中    String uuid &#x3D; UUID.randomUUID().toString();    &#x2F;&#x2F;2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！    String skuId &#x3D; &quot;25&quot;; &#x2F;&#x2F; 访问skuId 为25号的商品 100008348542    String locKey &#x3D; &quot;lock:&quot; + skuId; &#x2F;&#x2F; 锁住的是每个商品的数据    &#x2F;&#x2F; 3 获取锁    Boolean lock &#x3D; redisTemplate.opsForValue().setIfAbsent(locKey, uuid, 3, TimeUnit.SECONDS);    &#x2F;&#x2F; 第一种： lock 与过期时间中间不写任何的代码。    &#x2F;&#x2F; redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);&#x2F;&#x2F;设置过期时间    &#x2F;&#x2F; 如果true    if (lock) &#123;        &#x2F;&#x2F; 执行的业务逻辑开始        &#x2F;&#x2F; 获取缓存中的num 数据        Object value &#x3D; redisTemplate.opsForValue().get(&quot;num&quot;);        &#x2F;&#x2F; 如果是空直接返回        if (StringUtils.isEmpty(value)) &#123;            return;        &#125;        &#x2F;&#x2F; 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！        int num &#x3D; Integer.parseInt(value + &quot;&quot;);        &#x2F;&#x2F; 使num 每次+1 放入缓存        redisTemplate.opsForValue().set(&quot;num&quot;, String.valueOf(++num));        &#x2F;*使用lua脚本解锁*&#x2F;        &#x2F;&#x2F; 定义lua 脚本        String script &#x3D; &quot;if redis.call(&#39;get&#39;, KEYS[1]) &#x3D;&#x3D; ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;;        &#x2F;&#x2F; 使用redis执行lua执行        DefaultRedisScript&lt;Long&gt; redisScript &#x3D; new DefaultRedisScript&lt;&gt;();        redisScript.setScriptText(script);        &#x2F;&#x2F; 设置一下返回值类型 为Long        &#x2F;&#x2F; 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，        &#x2F;&#x2F; 那么返回字符串与0 会有发生错误。        redisScript.setResultType(Long.class);        &#x2F;&#x2F; 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。        redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);    &#125; else &#123;        &#x2F;&#x2F; 其他线程等待        try &#123;            &#x2F;&#x2F; 睡眠            Thread.sleep(1000);            &#x2F;&#x2F; 睡醒了之后，调用方法。            testLockLua();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>加锁</li></ol><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 1. 从redis中获取锁,set k1 v1 px 20000 nxString uuid &#x3D; UUID.randomUUID().toString();Boolean lock &#x3D; this.redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, uuid, 2, TimeUnit.SECONDS);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>解锁</li></ol><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 2. 释放锁 delString script &#x3D; &quot;if redis.call(&#39;get&#39;, KEYS[1]) &#x3D;&#x3D; ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;;&#x2F;&#x2F; 设置lua脚本返回的数据类型DefaultRedisScript&lt;Long&gt; redisScript &#x3D; new DefaultRedisScript&lt;&gt;();&#x2F;&#x2F; 设置lua脚本返回类型为LongredisScript.setResultType(Long.class);redisScript.setScriptText(script);redisTemplate.execute(redisScript, Arrays.asList(&quot;lock&quot;),uuid);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>重试</li></ol><pre class="line-numbers language-none"><code class="language-none">Thread.sleep(500);testLock();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p><ul><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li><li>加锁和解锁必须具有原子性。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> -笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目部署demo</title>
      <link href="/2022/09/18/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/09/18/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h1><h2 id="一、JENKINS（手动打包）"><a href="#一、JENKINS（手动打包）" class="headerlink" title="一、JENKINS（手动打包）"></a>一、JENKINS（手动打包）</h2><h3 id="1、创建普通SPRINGBOOT工程"><a href="#1、创建普通SPRINGBOOT工程" class="headerlink" title="1、创建普通SPRINGBOOT工程"></a>1、创建普通SPRINGBOOT工程</h3><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img00d5af84edb43316aa58856970a5eaed.png" alt="在这里插入图片描述"></p><h3 id="2、把工程进行打包，运行"><a href="#2、把工程进行打包，运行" class="headerlink" title="2、把工程进行打包，运行"></a>2、把工程进行打包，运行</h3><p>（1）把项目打包，因为SpringBoot工程，通过main方法执行，打包变成jar包形式，使用maven进行打包操作</p><ul><li>前提条件：安装好maven，配置环境变量</li><li>进入到项目目录中，使用maven命令： mvn clean package</li></ul><p>（2）打包完成之后，在项目target目录中找到jar包</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img9e221f67eec9b413c3b0ec98100447c9.png" alt="在这里插入图片描述"><br>（3）把打成jar包运行</p><ul><li>进入jar包所在目录，使用命令运行： java –jar jar包名称<br><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img41fe6883762999d83b925f4c5ab829d9.png" alt="在这里插入图片描述"></li></ul><h2 id="二、JENKINS的安装（自动打包）"><a href="#二、JENKINS的安装（自动打包）" class="headerlink" title="二、JENKINS的安装（自动打包）"></a>二、JENKINS的安装（自动打包）</h2><h3 id="1-准备代码，提交到码云Git库"><a href="#1-准备代码，提交到码云Git库" class="headerlink" title="1. 准备代码，提交到码云Git库"></a>1. 准备代码，提交到码云Git库</h3><p>代码中需要包含以下几部分内容：</p><h4 id="（1）代码中需要包含Dockerfile文件"><a href="#（1）代码中需要包含Dockerfile文件" class="headerlink" title="（1）代码中需要包含Dockerfile文件"></a>（1）代码中需要包含Dockerfile文件</h4><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img876a9e97eb427f398569b90608399477.png" alt=" "></p><p><strong>文件内容</strong>：</p><pre class="line-numbers language-none"><code class="language-none">FROM openjdk:8-jdk-alpineVOLUME &#x2F;tmpCOPY .&#x2F;target&#x2F;demojenkins.jar demojenkins.jar【以后只需要修改这里的目录 和对象即可】ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;&#x2F;demojenkins.jar&quot;, &quot;&amp;&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（2）在项目pom文件中指定打包类型，包含build部分内容"><a href="#（2）在项目pom文件中指定打包类型，包含build部分内容" class="headerlink" title="（2）在项目pom文件中指定打包类型，包含build部分内容"></a><strong>（2）在项目pom文件中指定打包类型，包含build部分内容</strong></h4><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgdde55806d40a0062d42b05b85dd49898.png" alt="image-20210311141706882"></p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img997afd0f53f4439fe78183089f740319-16656680918834.png" alt="image-20210311141711006"></p><h3 id="2、安装JAVA-运行环境"><a href="#2、安装JAVA-运行环境" class="headerlink" title="2、安装JAVA 运行环境"></a>2、安装JAVA 运行环境</h3><h4 id="第一步：上传或下载安装包"><a href="#第一步：上传或下载安装包" class="headerlink" title="第一步：上传或下载安装包"></a>第一步：上传或下载安装包</h4><pre class="line-numbers language-none"><code class="language-none">cd&#x2F;usr&#x2F;localjdk-8u121-linux-x64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="第二步：解压安装包"><a href="#第二步：解压安装包" class="headerlink" title="第二步：解压安装包"></a>第二步：解压安装包</h4><pre class="line-numbers language-none"><code class="language-none">tar -zxvf jdk-8u121-linux-x64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="第三步：建立软连接"><a href="#第三步：建立软连接" class="headerlink" title="第三步：建立软连接"></a>第三步：建立软连接</h4><pre class="line-numbers language-none"><code class="language-none">ln -s &#x2F;usr&#x2F;local&#x2F;jdk1.8.0_121&#x2F; &#x2F;usr&#x2F;local&#x2F;jdk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="第四步：修改环境变量"><a href="#第四步：修改环境变量" class="headerlink" title="第四步：修改环境变量"></a>第四步：修改环境变量</h4><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;etc&#x2F;profileexport JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdkexport JRE_HOME&#x3D;$JAVA_HOME&#x2F;jreexport CLASSPATH&#x3D;.:$CLASSPATH:$JAVA_HOME&#x2F;lib:$JRE_HOME&#x2F;libexport PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin# 通过命令source &#x2F;etc&#x2F;profile让profile文件立即生效source &#x2F;etc&#x2F;profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第五步、测试是否安装成功"><a href="#第五步、测试是否安装成功" class="headerlink" title="第五步、测试是否安装成功"></a>第五步、测试是否安装成功</h4><p>使用<code>java -version</code>，出现版本则安装成功</p><h3 id="3、安装maven"><a href="#3、安装maven" class="headerlink" title="3、安装maven"></a>3、安装maven</h3><h4 id="第一步：上传或下载安装包-1"><a href="#第一步：上传或下载安装包-1" class="headerlink" title="第一步：上传或下载安装包"></a>第一步：上传或下载安装包</h4><pre class="line-numbers language-none"><code class="language-none">cd &#x2F;usr&#x2F;localapache-maven-3.6.1-bin.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="第二步：解压安装包-1"><a href="#第二步：解压安装包-1" class="headerlink" title="第二步：解压安装包"></a>第二步：解压安装包</h4><pre class="line-numbers language-none"><code class="language-none">tar -zxvf apache-maven-3.6.1-bin.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="第三步：建立软连接-1"><a href="#第三步：建立软连接-1" class="headerlink" title="第三步：建立软连接"></a>第三步：建立软连接</h4><pre class="line-numbers language-none"><code class="language-none">ln -s &#x2F;usr&#x2F;local&#x2F;apache-maven-3.6.1&#x2F; &#x2F;usr&#x2F;local&#x2F;maven<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="第四步：修改环境变量-1"><a href="#第四步：修改环境变量-1" class="headerlink" title="第四步：修改环境变量"></a>第四步：修改环境变量</h4><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;etc&#x2F;profileexport MAVEN_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;mavenexport PATH&#x3D;$PATH:$MAVEN_HOME&#x2F;bin# 通过命令source &#x2F;etc&#x2F;profile让profile文件立即生效source &#x2F;etc&#x2F;profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第五步：测试是否安装成功"><a href="#第五步：测试是否安装成功" class="headerlink" title="第五步：测试是否安装成功"></a>第五步：测试是否安装成功</h4><pre class="line-numbers language-none"><code class="language-none">mvn –v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、安装git"><a href="#4、安装git" class="headerlink" title="4、安装git"></a>4、安装git</h3><pre class="line-numbers language-none"><code class="language-none">yum -y install git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5、安装docker"><a href="#5、安装docker" class="headerlink" title="5、安装docker"></a>5、安装docker</h3><h4 id="第一步：安装必要的一些系统工具"><a href="#第一步：安装必要的一些系统工具" class="headerlink" title="第一步：安装必要的一些系统工具"></a>第一步：安装必要的一些系统工具</h4><pre class="line-numbers language-none"><code class="language-none">yum install -y yum-utils device-mapper-persistent-data lvm2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="第二步：添加软件源信息"><a href="#第二步：添加软件源信息" class="headerlink" title="第二步：添加软件源信息"></a>第二步：添加软件源信息</h4><pre class="line-numbers language-none"><code class="language-none">yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="第三步：更新并安装Docker-CE"><a href="#第三步：更新并安装Docker-CE" class="headerlink" title="第三步：更新并安装Docker-CE"></a>第三步：更新并安装Docker-CE</h4><pre class="line-numbers language-none"><code class="language-none">yum makecache fastyum -y install docker-ce<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="第四步：开启Docker服务"><a href="#第四步：开启Docker服务" class="headerlink" title="第四步：开启Docker服务"></a>第四步：开启Docker服务</h4><pre class="line-numbers language-none"><code class="language-none">service docker start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="第五步、测试是否安装成功-1"><a href="#第五步、测试是否安装成功-1" class="headerlink" title="第五步、测试是否安装成功"></a>第五步、测试是否安装成功</h4><pre class="line-numbers language-none"><code class="language-none">docker -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6、安装Jenkins"><a href="#6、安装Jenkins" class="headerlink" title="6、安装Jenkins"></a>6、安装Jenkins</h3><h4 id="第一步：上传或下载安装包-2"><a href="#第一步：上传或下载安装包-2" class="headerlink" title="第一步：上传或下载安装包"></a>第一步：上传或下载安装包</h4><pre class="line-numbers language-none"><code class="language-none">cd &#x2F;usr&#x2F;local&#x2F;jenkinsjenkins.war<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="第二步：启动"><a href="#第二步：启动" class="headerlink" title="第二步：启动"></a>第二步：启动</h4><pre class="line-numbers language-none"><code class="language-none">nohup java -jar &#x2F;usr&#x2F;local&#x2F;jenkins&#x2F;jenkins.war &gt;&#x2F;usr&#x2F;local&#x2F;jenkins&#x2F;jenkins.out &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img6aff446b9796998f6f4f9506dd8bff5c.png" alt="img"></p><h4 id="第三步：访问"><a href="#第三步：访问" class="headerlink" title="第三步：访问"></a>第三步：访问</h4><p>系统ip:8080</p><h3 id="7、初始化-Jenkins-插件和管理员用户"><a href="#7、初始化-Jenkins-插件和管理员用户" class="headerlink" title="7、初始化 Jenkins 插件和管理员用户"></a><strong>7、初始化 Jenkins 插件和管理员用户</strong></h3><h4 id="访问jenkins"><a href="#访问jenkins" class="headerlink" title="访问jenkins"></a>访问jenkins</h4><ul><li>使用当前linux系统ip地址:8080端口号  系统ip:8080</li><li>首先进入初始化界面，需要多等一会，之后进入到下面界面<br><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img2a4fb7b20748f35b84af7672dbda294c.png" alt="在这里插入图片描述"></li></ul><h4 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h4><ul><li>找到管理员密码进行输入<br><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img11e3c8d8648871cbba71853b7f724da9-16657151520224.png" alt="在这里插入图片描述"></li><li>查看提示文件内容，复制默认密码到输入框里面<br><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img7b585eb549ef4a1e28293dc13f090431.png" alt="在这里插入图片描述"></li><li>输入正确密码，点击继续。<br><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imga67df3a5f4e088dfaba5c74ede14dd09.png" alt="在这里插入图片描述"><br><code>注意：进入安装插件页面，不要往下进行了，下载插件会很慢，配置国内镜像，为了提高下载速度，关掉浏览器，去配置镜像</code></li></ul><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img3794ffcc207c02d35aa58b09bb002c63.png" alt="在这里插入图片描述"></p><h4 id="配置国内镜像"><a href="#配置国内镜像" class="headerlink" title="配置国内镜像"></a>配置国内镜像</h4><p><code>cd /root/.jenkins/updates #</code>进入更新配置位置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> -i <span class="token string">'s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g'</span> default.json <span class="token operator">&amp;&amp;</span> <span class="token function">sed</span> -i <span class="token string">'s/http:\/\/www.google.com/https:\/\/www.baidu.com/g'</span> default.json<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imge61513723f35e30e2415ac165a65a218.png" alt="在这里插入图片描述"></p><h4 id="重启jenkins，运行管理界面，安装插件"><a href="#重启jenkins，运行管理界面，安装插件" class="headerlink" title="重启jenkins，运行管理界面，安装插件"></a>重启jenkins，运行管理界面，安装插件</h4><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img372851b0e4e611a3e5737f0db5a67618.png" alt="在这里插入图片描述"><br><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgf332e8e19b939198eaa817d7b238031b.png" alt="在这里插入图片描述"></p><h4 id="安装插件之后，插件管理员用户名和密码"><a href="#安装插件之后，插件管理员用户名和密码" class="headerlink" title="安装插件之后，插件管理员用户名和密码"></a>安装插件之后，插件管理员用户名和密码</h4><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img6a150c91f2699202321be5631126c355.png" alt="在这里插入图片描述"></p><h4 id="实例配置"><a href="#实例配置" class="headerlink" title="实例配置"></a>实例配置</h4><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img0918b5697b423112e6b95bc9d9e151e2.png" alt="在这里插入图片描述"></p><h4 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h4><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img768a85b219fcdac4e8ef735fa91c62bd.png" alt="在这里插入图片描述"></p><h3 id="8、JENKINS配置"><a href="#8、JENKINS配置" class="headerlink" title="8、JENKINS配置"></a>8、JENKINS配置</h3><h4 id="1、配置自动化部署需要环境"><a href="#1、配置自动化部署需要环境" class="headerlink" title="1、配置自动化部署需要环境"></a>1、配置自动化部署需要环境</h4><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imga8aa3be28ab1c7ab57725fbd9cecabb9.png" alt="在这里插入图片描述"><br><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img573b100934462bd68c81724e70acbab0.png" alt="在这里插入图片描述"></p><h4 id="2、配置JDK环境"><a href="#2、配置JDK环境" class="headerlink" title="2、配置JDK环境"></a>2、配置JDK环境</h4><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgefa63a887ed94bdfb62de5d2b28b986e.png" alt="在这里插入图片描述"></p><h4 id="3、配置MAVEN环境"><a href="#3、配置MAVEN环境" class="headerlink" title="3、配置MAVEN环境"></a>3、配置MAVEN环境</h4><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img85b26f7691860e15aac39be80329b6af.png" alt="在这里插入图片描述"></p><h4 id="4、配置GIT环境"><a href="#4、配置GIT环境" class="headerlink" title="4、配置GIT环境"></a>4、配置GIT环境</h4><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img7b48eef8149001b80292d9ba941adbd1.png" alt="在这里插入图片描述"></p><h3 id="9、JENKINS自动化过程"><a href="#9、JENKINS自动化过程" class="headerlink" title="9、JENKINS自动化过程"></a>9、JENKINS自动化过程</h3><h4 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h4><p>（1）需要项目工程，需要做修改<br>第一：项目需要Dockerfile文件<br><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imge44eefc47d625df75249a0a8974153ee.png" alt="在这里插入图片描述"><br>文件内容：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">FROM openjdk<span class="token operator">:</span><span class="token number">8</span><span class="token operator">-</span>jdk<span class="token operator">-</span>alpineVOLUME <span class="token operator">/</span>tmpCOPY <span class="token punctuation">.</span>/target<span class="token operator">/</span>demojenkins<span class="token punctuation">.</span>jar demojenkins<span class="token punctuation">.</span>jarENTRYPOINT <span class="token punctuation">[</span><span class="token string">"java"</span><span class="token punctuation">,</span><span class="token string">"-jar"</span><span class="token punctuation">,</span><span class="token string">"/demojenkins.jar"</span><span class="token punctuation">,</span> <span class="token string">"&amp;"</span><span class="token punctuation">]</span><span class="token number">1234</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二：在项目pom文件添加打包类型 和 maven插件</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgf5865afd43e5664ff03994d3f6864379.png" alt="在这里插入图片描述"></p><h4 id="2、在JENKINS管理界面创建自动化任务"><a href="#2、在JENKINS管理界面创建自动化任务" class="headerlink" title="2、在JENKINS管理界面创建自动化任务"></a>2、在JENKINS管理界面创建自动化任务</h4><p>（1）</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img0a82de3b4e14958fb996f96ecbf6e835.png" alt="在这里插入图片描述"><br>（2）<br><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgfed920f80f06f22a9c89b1d31ad0e9be.png" alt="在这里插入图片描述"><br>（3）把代码提交码云Git仓库里面</p><p>此时不会的可以查看<a href="https://blog.csdn.net/weixin_45606067/article/details/109536927">https://blog.csdn.net/weixin_45606067/article/details/109536927</a></p><p>（4）在作业创建页面指定代码位置<br><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img7eecb26204fe779b342677f09afeee5e.png" alt="在这里插入图片描述"><br>添加git用户，git的用户名与密码<br><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img2f88e0645d1df805ec7659683fa38453.png" alt="在这里插入图片描述"><br>选择添加的用户，上面的红色提示信息消失，说明连接成功。</p><p>（5）</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img7e2123d7d88f1a1db6e0419fa504b554.png" alt="在这里插入图片描述"><br>（6）修改脚本路径，进行复制</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img5b556b7eb1b2acd6b9e5f8aa39ced7f0.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment">#maven打包</span>mvn clean package<span class="token builtin class-name">echo</span> <span class="token string">'package ok!'</span><span class="token builtin class-name">echo</span> <span class="token string">'build start!'</span><span class="token builtin class-name">cd</span> ./infrastructure/eureka_server<span class="token assign-left variable">service_name</span><span class="token operator">=</span><span class="token string">"eureka-server"</span><span class="token assign-left variable">service_prot</span><span class="token operator">=</span><span class="token number">8761</span><span class="token comment">#查看镜像id</span><span class="token assign-left variable">IID</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> images <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"<span class="token variable">$service_name</span>"</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123;print $3&#125;'</span><span class="token variable">)</span></span><span class="token builtin class-name">echo</span> <span class="token string">"IID <span class="token variable">$IID</span>"</span><span class="token keyword">if</span> <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">$IID</span>"</span> <span class="token punctuation">]</span><span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">"exist <span class="token variable">$SERVER_NAME</span> image,IID=<span class="token variable">$IID</span>"</span>    <span class="token comment">#删除镜像</span>    <span class="token function">docker</span> rmi -f <span class="token variable">$service_name</span>    <span class="token builtin class-name">echo</span> <span class="token string">"delete <span class="token variable">$SERVER_NAME</span> image"</span>    <span class="token comment">#构建</span>    <span class="token function">docker</span> build -t <span class="token variable">$service_name</span> <span class="token builtin class-name">.</span>    <span class="token builtin class-name">echo</span> <span class="token string">"build <span class="token variable">$SERVER_NAME</span> image"</span><span class="token keyword">else</span>    <span class="token builtin class-name">echo</span> <span class="token string">"no exist <span class="token variable">$SERVER_NAME</span> image,build docker"</span>    <span class="token comment">#构建</span>    <span class="token function">docker</span> build -t <span class="token variable">$service_name</span> <span class="token builtin class-name">.</span>    <span class="token builtin class-name">echo</span> <span class="token string">"build <span class="token variable">$SERVER_NAME</span> image"</span><span class="token keyword">fi</span><span class="token comment">#查看容器id</span><span class="token assign-left variable">CID</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"<span class="token variable">$SERVER_NAME</span>"</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123;print $1&#125;'</span><span class="token variable">)</span></span><span class="token builtin class-name">echo</span> <span class="token string">"CID <span class="token variable">$CID</span>"</span><span class="token keyword">if</span> <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">$CID</span>"</span> <span class="token punctuation">]</span><span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">"exist <span class="token variable">$SERVER_NAME</span> container,CID=<span class="token variable">$CID</span>"</span>    <span class="token comment">#停止</span>    <span class="token function">docker</span> stop <span class="token variable">$service_name</span>    <span class="token comment">#删除容器</span>    <span class="token function">docker</span> <span class="token function">rm</span> <span class="token variable">$service_name</span><span class="token keyword">else</span>    <span class="token builtin class-name">echo</span> <span class="token string">"no exist <span class="token variable">$SERVER_NAME</span> container"</span><span class="token keyword">fi</span><span class="token comment">#启动</span><span class="token function">docker</span> run -d --name <span class="token variable">$service_name</span> --net<span class="token operator">=</span>host -p <span class="token variable">$service_prot</span><span class="token builtin class-name">:</span><span class="token variable">$service_prot</span> <span class="token variable">$service_name</span><span class="token comment">#查看启动日志</span><span class="token function">docker</span> logs -f  <span class="token variable">$service_name</span><span class="token number">12345678910111213141516171819202122232425262728293031323334353637383940414243</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>保存上面的构建作业<br><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img7c73b79604241957d328eeaa9553059d.png" alt="在这里插入图片描述"></li></ul><p>构建结构说明：</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img0224fd6c9558d9cfc751db2ec2cfef4d.png" alt="在这里插入图片描述"></p><p>（7）执行作业（任务）</p><ul><li>需要docker启动起来<br>service docker start</li></ul><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img8a7b0c9431901d1fd8bf45b689da333a.png" alt="在这里插入图片描述"></p><p>（8）看到控制台日志输出</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img9e2070ea70bbdc08e4f81d6ff2239aed.png" alt="在这里插入图片描述"><br>成功后的效果</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/img22ed5d16350681441ec73260aecc3097.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> -教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Typora+阿里云OSS图床搭建</title>
      <link href="/2022/04/15/%E4%BD%BF%E7%94%A8Typora+%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/04/15/%E4%BD%BF%E7%94%A8Typora+%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前使用和介绍过了Gitee的图床搭建，但没用几天就Gitee就加了防盗链，不能用了！所有只能掏钱买阿里云的OSS做图床了，查了下价钱也还能接受，新用户标准LRS存储一年也就9块钱。</p><p>下面就根据OSS配置再结合个人常用的软件来总结阿里云OSS相关配置和应用。</p><h2 id="安装软件（我这使用的是typora）"><a href="#安装软件（我这使用的是typora）" class="headerlink" title="安装软件（我这使用的是typora）"></a>安装软件（我这使用的是typora）</h2><p>鉴于此插件安装已有详细说明，在这里我就不重新搬运一边，大家可以参考一下下面的链接内容：<a href="https://github.com/Thobian/typora-plugins-win-img">安装说明</a></p><h2 id="购买阿里云oss"><a href="#购买阿里云oss" class="headerlink" title="购买阿里云oss"></a>购买阿里云oss</h2><p>1.首先区阿里云官网注册一个账号，这个很简单，点击下面链接小白式注册就行。</p><p><a href="https://www.aliyun.com/?spm=5176.12901015.ahjq0uaqt.1.4107525cJkgkaA">阿里云官网</a>：下面是阿里云主页官网，点进去注册即可。</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgtuchuang-20220415214226151.png" alt="image-20220415214226151"></p><p>2.购买阿里云存储服务<code>oss</code></p><p>注册好之后，在主页上面找到如下界面，点击对象存储<code>oos</code>，然后在点击折扣套餐</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimgtuchuang2.png" alt="1607057946516"></p><p>3.套餐选择</p><p>点进去之后，根据自己二点需要进行套餐选择，我选择的是一年，可能以后一直需要使用，最后点击购买即可。</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimgtuchuang3.png" alt="image-20220415201928841"></p><h2 id="配置阿里云OSS"><a href="#配置阿里云OSS" class="headerlink" title="配置阿里云OSS"></a>配置阿里云OSS</h2><p>1.进入官网：<a href="https://www.aliyun.com/">阿里云</a> ，在产品中选择 OSS，如果从来没开通过OSS，阿里云这里会给一份协议确认然后确认用户开通，这里就不截图了。</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimg27a509d5a3e39d4d43d5413e44a0a6a21977b5c6.png@942w_372h_progressive.webp" alt="img"></p><p>2.进入<code>管理控制台</code>页面，刚进去看不知道要干啥，可以直接点击右边的OSS新手入门来了解也是一种方式。</p><p>3.我们切换到<code>Bucket列表</code>，选择<code>创建Bucket</code>。</p><blockquote><p>购买之后我们创建相关的Burket然后上传的时候就会从资源包扣费了。</p><p>注意你创建的Burket一定要和你的资源包匹配！</p><p>注意你创建的Burket一定要和你的资源包匹配！</p></blockquote><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimgtuchuang-20220415204100227.png" alt="image-20220415204100227"></p><p>进入页面之后，我们填写下面的内容：</p><ul><li><p>Bucket名称，唯一命名，起个自己喜欢的名字即可。</p></li><li><p>地域：选择和自己所在城市比较近的城市，国内选择国内的区域和节点即可。</p></li><li><p>Endpoint：需要的话可以记录一下，比如我我选择的是：oss-cn-shenzhen.aliyuncs.com</p></li><li><p>存储类型：如果仅仅作为备份使用，低频访问比较合适，但是如果是对外使用不管流量多少还是建议用标准的，归档存储一般用于永久存储备份重要数据。</p></li><li><p>同城冗余和版本控制没啥必要，不用开。</p></li><li><p>读写权限：如果我们作为图床，需要用<code>公共读</code>允许匿名用户访问数据。（和PicGo配置有关）</p></li><li><p>实时日志和定期备份个人认为如果是自己用也是没有必要。</p></li></ul><p>4.AccessKey管理 </p><ul><li>接着是用户配置部分，我们需要在OSS中配置允许对外访问的AccessKey，这里我们点击右上角头像的<code>AccessKey管理</code>，这里其实用户体验不是很好。</li></ul><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimgtuchuang-20220415203226744.png" alt="image-20220415203226744"></p><ul><li><p>由于图床会对外访问，所以建议不要使用主账户的AccessToken进行操作，而是使用子账户</p><p>方式进行操作处理，这里进入之后可以看到RAM访问控制，点击<code>创建用户</code>。 </p></li><li><p><code>创建用户</code>其他都可以自由操作，但是一定要选择<code>Open API</code>，这里需要进行安全验证。创建</p><p>完成之后，我们便拥有了AccessKey ID，AccessKey Secret这两个关键配置。</p></li></ul><p><code>注意这两个配置只能查看一次，建议复制到自己本地存储后面需要使用到。 </code></p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimgimgtuchuang-20220415205213252.png" alt="image-20220415205213252"></p><p>5.设置权限</p><p>这时候就要给这个用户去设置权限。刚创建的子用户是没有任何权限的，这里你既然要对<code>OSS</code>进行上传写入的操作，肯定要给这个账户权限，可以看到在用户界面有拟刚才创建的子用户，并且可以配置权限</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimgtuchuang10.png" alt="1607060149151"></p><p>这里在权限搜索框内输入<code>OSS</code>，就可以看到我们要配置的权限（管理<code>OSS</code>的权限），点击确定即可。</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimgimgtuchuang-1a.png" alt="1607060173409"></p><h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><p>PicGo是什么这里就略过了，我们直接来看PicGo的配置</p><p>关键部分：在软件中我们选择<code>阿里云OSS配置</code>然后根据参数填写下面的内容：</p><ul><li><p>keyId：这里用之前新建的子用户的 AccessKey。</p></li><li><p>KeySecret：这里使用新建子用户的 AcessSecret。</p></li><li><p>存储空间名称：这里按照下图填写<strong>Bucket名称</strong>。</p></li><li><p>默认存储区域：这里按照下图填写Endpoint（地域节点），注意这里只需要.aliyuncs.com需要删除。</p></li></ul><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimgtuchuang-20220415211037874.png" alt="image-20220415211037874"></p><p>最后个人的配置如下： </p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgimgtuchuang-20220415210444183.png" alt="image-20220415210444183"></p><h2 id="配置Typera"><a href="#配置Typera" class="headerlink" title="配置Typera"></a>配置Typera</h2><p>安装Typera这里就跳过了，我们打开软件之后选择<code>图像</code>，然后切换到PicGo，验证一把之后会提示成功信息，之后我们修改上面<code>插入图片时....</code>的操作改为<code>上传图片</code>，以后图片都会PicGo进行上传，不会出现在本地的一个临时路径了。 </p><blockquote><p>这里不是很建议直接执行上传操作，更建议先放到一个指定文件夹然后确认无误之后进行复制粘贴的上传替换，当然OSS流量基本够用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> -教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -OSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（不能用了！！！）使用PicGo + Gitee(码云)实现markdown图床</title>
      <link href="/2022/04/10/%E4%BD%BF%E7%94%A8PicGo%20+%20Gitee(%E7%A0%81%E4%BA%91)%E5%AE%9E%E7%8E%B0markdown%E5%9B%BE%E5%BA%8A/"/>
      <url>/2022/04/10/%E4%BD%BF%E7%94%A8PicGo%20+%20Gitee(%E7%A0%81%E4%BA%91)%E5%AE%9E%E7%8E%B0markdown%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：搞完没几天Gitee加了防盗链，不能用了！！！"><a href="#前言：搞完没几天Gitee加了防盗链，不能用了！！！" class="headerlink" title="前言：搞完没几天Gitee加了防盗链，不能用了！！！"></a><strong>前言</strong>：搞完没几天Gitee加了防盗链，不能用了！！！</h2><p>最近正在搞个人博客，想在自己博客中插入的图片链接随时随地在线预览，然后在网上找到了知乎的LeonG分享的相关文章，用图床来实现。</p><blockquote><p>图床是干什么的？<br>图床就是一个便于在博文中插入在线图片连接的个人图片仓库。设置图床之后，在自己博客中插入的图片链接就可以随时随地在线预览了，并且不会因为任何意外原因无法查看，除非自己亲自删除。</p></blockquote><p>神奇的<strong>PicGo</strong>就是为了解决这个问题诞生的，它可以将图片上传到指定的图床上，然后返回markdown链接，直接粘贴到你的文档中，就搞定啦</p><p>问题又来了，网上推荐七牛云阿里云都是要租赁服务器的，太麻烦还要钱，微博现在挂链接又很厉害。大部分人选择用github，但是github虽好却是国外的网站，速度终究比不上国内网站，研究了小半天，最终决定使用PicGo + 国内的github - <a href="https://link.zhihu.com/?target=https://gitee/com">码云</a>来实现markdown图床</p><p>废话说到这里，开始进入正题</p><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>首先下载 <a href="https://github.com/Molunerfinn/PicGo/releases">picgo安装包</a></li></ul><p>速度有点慢，没关系（想要更快可以自行百度下载油猴插件）</p><ul><li><p>安装之后打开主界面，选择最底下的插件设置，搜索<strong>gitee</strong></p></li><li><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imga1.png" alt="a1">点击安装gitee-uploader 1.1.2开始安装</p></li></ul><blockquote><p>这里注意一下，必须要先安装[node.js]才能安装插件，没装的自己装一下，然后重启就行。</p></blockquote><p>这个里我使用<strong>gitee-uploader 1.1.2</strong> 插件，gitee2.0.5插件上传的时候莫名有点问题。</p><hr><h2 id="建立gitee（码云）图床库"><a href="#建立gitee（码云）图床库" class="headerlink" title="建立gitee（码云）图床库"></a>建立gitee（码云）图床库</h2><p>注册码云的方法很简单，网站引导都是中文，不多说了，我们直接建立自己的图床库。(Gitee Pages 服务现在需要实名认证)</p><p>点击右上角的+号，新建仓库</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imga2.png" alt="a2"></p><p><strong>新建仓库的要点如下：</strong></p><ol><li>输入一个仓库名称，点击创建，创建之后显示以下界面，点击<strong>初始化readme文件</strong>（这个选项勾上，这样码云会自动给你的仓库建立master分支，这点很重要！）</li><li>初始化之后点击右边的管理，基本信息那把<strong>开源</strong>勾选保存（需要同意3个条款）</li></ol><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgblog6.jpg" alt="blog4"></p><hr><h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><p>安装了<strong>gitee-uploader 1.1.2</strong>插件之后，我们开始配置插件</p><p>配置插件的要点如下：</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imga4.png" alt="a4"></p><ul><li><p>repo：用户名&#x2F;仓库名称，比如我自己的仓库a-xiaoming&#x2F;img，找不到的可以直接复制仓库的url</p></li><li><p>branch：分支，这里写上master</p></li><li><p>token：填入码云的私人令牌</p></li><li><p>path：路径，一般写上imges</p></li><li><p>customPath：提交消息，这一项和下一项customURL都不用填。在提交到码云后，会显示提交消息，插件默认提交的是 <code>Upload 图片名 by picGo - 时间</code></p></li></ul><h3 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h3><ol><li><p>登录进自己的码云</p></li><li><p>点击头像，进入设置</p></li><li><p>找到右边安全设置里面的私人令牌</p></li><li><p>点击<code>生成新令牌</code>，把<strong>projects</strong>这一项勾上，其他的不用勾，然后提交</p></li></ol><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imga6.png" alt="a6"></p><p>这里需要验证一下密码，验证密码之后会出来一串数字，这一串数字就是你的token，将这串数字复制到刚才的配置里面去。</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imga7.png"></p><blockquote><p><strong>注意：这个令牌只会明文显示一次，建议在配置插件的时候再来生成令牌，直接复制进去，搞丢了又要重新生成一个。</strong></p></blockquote><p>现在保存你刚才的配置，然后将它设置为默认图床，大功告成。</p><hr><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>随便选一张图片上传（picgo也支持剪贴板上传），试试看，超级快有木有！比github快很多，0.1秒上传，而且导入到你的markdown编辑器里面也是秒识别你的图片内容。</p><p>上传之后默认复制链接，直接粘贴到你的markdown编辑器里，就可以愉快的进行写作了！</p><hr><h2 id="可能出现的一些问题"><a href="#可能出现的一些问题" class="headerlink" title="可能出现的一些问题"></a>可能出现的一些问题</h2><p>这里我挂一个我看到的 <a href="https://blog.csdn.net/m0_46503920/article/details/117917048">使用PicGo+gitee 搭建图床遇到的一些问题</a></p>]]></content>
      
      
      <categories>
          
          <category> -教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo +Gitee搭建个人博客</title>
      <link href="/2022/03/23/%E4%BD%BF%E7%94%A8Hexo-Gitee%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/03/23/%E4%BD%BF%E7%94%A8Hexo-Gitee%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>Gitee Pagas要实名认证了，可先去注册Gitee先实名认证</li></ul><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><ul><li>Windows系统电脑</li><li><a href="https://git-scm.com/">Git</a></li><li><a href="https://nodejs.org/en/">Node.js</a></li></ul><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>因为我们要用到<a href="https://git-scm.com/">Git</a>中的<a href="https://git-scm.com/download/win">Git Bash</a>，类似于Windows的cmd命令行，不过要好用许多(我开始是用cmd按视频的步骤来的，运行命令容易报错)。</p><ul><li><p><a href="https://git-scm.com/download/win">下载地址</a></p></li><li><p>安装步骤：双击下载好的exe文件，一路点击next就好了</p></li><li><p>安装完成之后打开Git Bash，输入</p><pre class="line-numbers language-none"><code class="language-none">git version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看版本：(我这里安装的版本是2.35.1)</p><pre class="line-numbers language-none"><code class="language-none">$ git version git version 2.35.1.windows.2 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>能看到版本号就说明你安装成功了，之后的命令都是在这里运行的</p></li></ul><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p><a href="https://hexo.io/">Hexo</a>是基于<a href="https://nodejs.org/en/">Node.js</a>制作的静态博客，我们要用到Node.js里面的<a href="https://www.npmjs.cn/">npm</a>(node package manager)包管理器来安装插件，如果你想玩Hexo博客，那么这个Node.js是必装的。</p><ul><li><p><a href="https://nodejs.org/en/download/">下载地址</a>(选择自己电脑版本相对应的包来下载)</p></li><li><p>安装步骤：双击下载好的msi文件，也是一路下一步就好了</p></li><li><p>安装完成后打开Git Bash，输入<code>node -v</code>和<code>npm -v</code>查看node和npm的版本：</p><pre class="line-numbers language-none"><code class="language-none">$ node -vv12.14.1$ npm -v6.13.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>到这里前置步骤就已经算完成了，接下来我们就来安装Hexo博客</p></li></ul><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>安装<a href="https://hexo.io/">Hexo</a>，我们需要借助<a href="https://www.npmjs.cn/">npm</a>这个工具来安装，但是我们国内下载镜像源的速度很慢，所以我们可以先利用npm工具来安装一个<a href="https://npm.taobao.org/">cnpm</a>工具(国内的淘宝npm镜像源)，这样一来速度会快很多。</p><ul><li><p>安装cnpm：(安装完之后照样可以用’cn’<code>cnpm -v</code>来查看版本号验证是否成功)</p><pre class="line-numbers language-none"><code class="language-none">$ npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>用cnpm安装Hexo</p><pre class="line-numbers language-none"><code class="language-none">$ cnpm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>接着用<code>Hexo -v</code>来验证是否安装成功</p><pre class="line-numbers language-none"><code class="language-none">$ hexo -vhexo-cli: 3.1.0os: Windows_NT 10.0.17134 win32 x64node: 12.14.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果出现以上信息，那么恭喜安装成功了</p></li></ul><h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><ul><li><p>在你的电脑上建一个文件夹，命名没有要求，我这里创建的是blog，文件夹路径也无所谓，最好装在出了系统盘的固态硬盘中，路径要自己找得到。</p></li><li><p>在创建的文件夹目录下右键选择<code>Git Bash Here</code>，也就是在此处打开Git Bash终端</p></li><li><p>输入Hexo初始化命令</p></li></ul><pre class="line-numbers language-none"><code class="language-none">$ hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个命令执行需要一定的时间，请耐心等待</p><p>初始化完成之后可以查看指定文件夹目录下有：</p><ol><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ol><ul><li>打开Hexo服务</li></ul><pre class="line-numbers language-none"><code class="language-none">$ hexo sINFO  Start processingINFO  Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样你就可以再浏览器输入:localhost:4000来访问你的博客啦，使用Ctrl+C可以关闭服务。</p><p>大概是这样：</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgblog.jpg" alt="blog"></p><ul><li>用Hexo写一篇博客</li></ul><pre class="line-numbers language-none"><code class="language-none">$ hexo new &quot;我的第一篇博客&quot;INFO  Created: E:\bolg\source\_posts\我的第一篇博客.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>到D:\bolg\source_posts目录下打开我的第一篇博客.md进行编辑(我使用的是Typora)：</li></ul><pre class="line-numbers language-none"><code class="language-none">---title: 我的第一篇博客date: 2020-02-03 21:16:52tags:---## 第一章内容---## 第二章内容---## 参考资料https:&#x2F;&#x2F;ouwen.gitee.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：这里的md文件是基于markdown语法进行编辑的，不了解的朋友可以百度学习一下，很简单的，几分钟就能看明白，相信你不是问题。</p><ul><li>编辑完保存文件，重启Hexo服务</li></ul><pre class="line-numbers language-none"><code class="language-none">$ hexo clean          # 清除所有记录 $ hexo generate       # 生成静态网页 简写：hexo g$ hexo server         # 启动服务 简写：hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>打开浏览器输入localhost:4000：</li></ul><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgblog2.jpg" alt="blog2"></p><h2 id="将博客部署到Gitee上"><a href="#将博客部署到Gitee上" class="headerlink" title="将博客部署到Gitee上"></a>将博客部署到Gitee上</h2><p>上面访问的localhost:4000是本地服务器端口，我们的博客不可能是放在本地服务器的，我们需要把博客部署到远端去。我这里推荐的一个免费的部署的方式就是部署到<a href="https://gitee.com/">Gitee</a>上，部署好之后就可以通过访问<a href="https://gitee.com/">Gitee</a>上的那个地址来访问我们的博客。</p><ul><li><p>进到<a href="https://gitee.com/">Gitee</a>官网，注册账号并登陆</p></li><li><p>点击个人主页右上角新建个人仓库(我这已经创建过了)</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgblog3.jpg" alt="blog3"></p></li><li><p>点进已经创建的仓库（blog），点击管理，把仓库设置为开源，保存</p><p> <img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgblog6.jpg" alt="blog6"></p></li><li><p>打开Hexo的配置文件<code>_config.yml</code> <strong>注意冒号后面都有一个空格</strong></p> <pre class="line-numbers language-none"><code class="language-none">type: gitrepo: https:&#x2F;&#x2F;gitee.com&#x2F;a-xiaoming&#x2F;blog #仓库的urlbranch: master <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>这里先安装一个Hexo插件</p><pre class="line-numbers language-none"><code class="language-none">cnpm install hexo-deployer-git --save  #通过cpnm安装git插件git config --global user.email &#39;******@qq.com&#39;  #设置gitee邮箱（gitee的注册邮箱）git config --global user.name &#39;****&#39;            #设置用户名（gitee的y注册昵称）hexo d  #上传到gitee的远端仓库# 在上传时，需要再次输入gitee的用户名username和密码password<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>上传成功仓库会多出一些文件</p><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgblog4.jpg" alt="blog4"></p></li><li><p>然后<strong>勾选强制使用HTTPS</strong>，点击启动或更新之后</p></li><li><p>访问Gitee Page服务的网站地址就可以成功将本地的博客部署到了远端仓库，这样你的小伙伴也能在自己的电脑访问你的Gitee Page服务网站看到你的博客啦。</p><p><strong>注意每次更改网页重新上传到仓库都要到这里来更新服务。</strong></p></li></ul><p><img src="https://a-xiaoming.oss-cn-beijing.aliyuncs.com/imgblog5.jpg" alt="blog5"></p>]]></content>
      
      
      <categories>
          
          <category> -教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -gitee </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
